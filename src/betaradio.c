/* betaradio.c generated by valac 0.22.1, the Vala compiler
 * generated from betaradio.vala, do not modify */

/* -*- coding: utf-8; indent-tabs-mode: nil; tab-width: 4; c-basic-offset: 4; -*- */
/* vim:set fileencodings=utf-8 tabstop=4 expandtab shiftwidth=4 softtabstop=4: */

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <any-tray-icon.h>
#include <stdlib.h>
#include <string.h>
#include <X11/Xlib.h>
#include <X11/Xatom.h>
#include <X11/Xutil.h>
#include <X11/Xregion.h>
#include <gst/gst.h>
#include <glib/gi18n-lib.h>
#include <config.h>
#include <stdio.h>
#include <gio/gio.h>


#define TYPE_BETA_RADIO (beta_radio_get_type ())
#define BETA_RADIO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_BETA_RADIO, BetaRadio))
#define BETA_RADIO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_BETA_RADIO, BetaRadioClass))
#define IS_BETA_RADIO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_BETA_RADIO))
#define IS_BETA_RADIO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_BETA_RADIO))
#define BETA_RADIO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_BETA_RADIO, BetaRadioClass))

typedef struct _BetaRadio BetaRadio;
typedef struct _BetaRadioClass BetaRadioClass;
typedef struct _BetaRadioPrivate BetaRadioPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef struct _Block1Data Block1Data;

#define TYPE_GST_PLAYER (gst_player_get_type ())
#define GST_PLAYER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GST_PLAYER, GstPlayer))
#define GST_PLAYER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GST_PLAYER, GstPlayerClass))
#define IS_GST_PLAYER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GST_PLAYER))
#define IS_GST_PLAYER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GST_PLAYER))
#define GST_PLAYER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GST_PLAYER, GstPlayerClass))

typedef struct _GstPlayer GstPlayer;
typedef struct _GstPlayerClass GstPlayerClass;
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

#define TYPE_JSON_SOUP (json_soup_get_type ())
#define JSON_SOUP(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_JSON_SOUP, JsonSoup))
#define JSON_SOUP_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_JSON_SOUP, JsonSoupClass))
#define IS_JSON_SOUP(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_JSON_SOUP))
#define IS_JSON_SOUP_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_JSON_SOUP))
#define JSON_SOUP_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_JSON_SOUP, JsonSoupClass))

typedef struct _JsonSoup JsonSoup;
typedef struct _JsonSoupClass JsonSoupClass;
#define _g_free0(var) (var = (g_free (var), NULL))
typedef struct _Block2Data Block2Data;
typedef struct _Block3Data Block3Data;
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))

struct _BetaRadio {
	GObject parent_instance;
	BetaRadioPrivate * priv;
};

struct _BetaRadioClass {
	GObjectClass parent_class;
};

struct _BetaRadioPrivate {
	GtkMenu* menu;
	AnyTrayIcon* icon;
};

struct _Block1Data {
	int _ref_count_;
	gboolean is_running;
};

struct _Block2Data {
	int _ref_count_;
	BetaRadio * self;
	gchar* title;
	gchar* url;
};

struct _Block3Data {
	int _ref_count_;
	BetaRadio * self;
	gchar* title;
	gchar* url;
};


static gpointer beta_radio_parent_class = NULL;

GType beta_radio_get_type (void) G_GNUC_CONST;
#define BETA_RADIO_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_BETA_RADIO, BetaRadioPrivate))
enum  {
	BETA_RADIO_DUMMY_PROPERTY
};
gint beta_radio_main (gchar** args, int args_length1);
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (void * _userdata_);
static void __lambda2_ (Block1Data* _data1_);
BetaRadio* beta_radio_new (void);
BetaRadio* beta_radio_construct (GType object_type);
static void ___lambda2__g_application_activate (GApplication* _sender, gpointer self);
static void* ___lambda3_ (BetaRadio* self);
static void __lambda4_ (BetaRadio* self, GtkCheckMenuItem* e);
GType gst_player_get_type (void) G_GNUC_CONST;
GstPlayer* gst_player_get_instance (void);
void gst_player_stop (GstPlayer* self);
static void ___lambda4__gtk_check_menu_item_toggled (GtkCheckMenuItem* _sender, gpointer self);
static GSList* beta_radio_getMenu (BetaRadio* self, GtkMenu* menu, GSList* group);
static void __lambda7_ (BetaRadio* self, GtkCheckMenuItem* e);
static void ___lambda7__gtk_check_menu_item_toggled (GtkCheckMenuItem* _sender, gpointer self);
static gpointer ____lambda3__gthread_func (gpointer self);
GType json_soup_get_type (void) G_GNUC_CONST;
JsonSoup* json_soup_new_http (const gchar* url);
JsonSoup* json_soup_construct_http (GType object_type, const gchar* url);
gboolean json_soup_is_array (JsonSoup* self);
gint json_soup_length (JsonSoup* self);
JsonSoup* json_soup_array (JsonSoup* self, gint idx);
gchar* json_soup_get_string (JsonSoup* self);
JsonSoup* json_soup_object (JsonSoup* self, const gchar* name);
gboolean json_soup_is_string (JsonSoup* self);
JsonSoup* json_soup_sibling (JsonSoup* self, const gchar* name);
static GSList* beta_radio_getCategoryMenu (BetaRadio* self, GtkMenu* menu, GSList* group, JsonSoup* json);
static GSList* beta_radio_getChannelMenu (BetaRadio* self, GtkMenu* menu, GSList* group, JsonSoup* json);
JsonSoup* json_soup_parent (JsonSoup* self);
static Block2Data* block2_data_ref (Block2Data* _data2_);
static void block2_data_unref (void * _userdata_);
static gchar* beta_radio_filter_url (BetaRadio* self, const gchar* url, const gchar* type);
static void ________lambda5_ (Block2Data* _data2_, GtkCheckMenuItem* e);
void gst_player_play (GstPlayer* self, const gchar* title, const gchar* url);
static void _________lambda5__gtk_check_menu_item_toggled (GtkCheckMenuItem* _sender, gpointer self);
JsonSoup* json_soup_grandparent (JsonSoup* self);
static Block3Data* block3_data_ref (Block3Data* _data3_);
static void block3_data_unref (void * _userdata_);
static void _____lambda6_ (Block3Data* _data3_, GtkCheckMenuItem* e);
static void ______lambda6__gtk_check_menu_item_toggled (GtkCheckMenuItem* _sender, gpointer self);
static void beta_radio_finalize (GObject* obj);


static Block1Data* block1_data_ref (Block1Data* _data1_) {
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}


static void block1_data_unref (void * _userdata_) {
	Block1Data* _data1_;
	_data1_ = (Block1Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		g_slice_free (Block1Data, _data1_);
	}
}


static void __lambda2_ (Block1Data* _data1_) {
	gboolean _tmp0_ = FALSE;
	BetaRadio* instance = NULL;
	BetaRadio* _tmp1_ = NULL;
	_tmp0_ = _data1_->is_running;
	if (_tmp0_) {
		return;
	}
	_data1_->is_running = TRUE;
	_tmp1_ = beta_radio_new ();
	instance = _tmp1_;
	gtk_main ();
	_g_object_unref0 (instance);
	instance = NULL;
	_g_object_unref0 (instance);
}


static void ___lambda2__g_application_activate (GApplication* _sender, gpointer self) {
	__lambda2_ (self);
}


gint beta_radio_main (gchar** args, int args_length1) {
	gint result = 0;
	Block1Data* _data1_;
	gboolean _tmp0_ = FALSE;
	GApplication* app = NULL;
	GApplication* _tmp2_ = NULL;
	GApplication* _tmp3_ = NULL;
	GApplication* _tmp4_ = NULL;
	gint _tmp5_ = 0;
	_data1_ = g_slice_new0 (Block1Data);
	_data1_->_ref_count_ = 1;
	XInitThreads ();
	gtk_init (&args_length1, &args);
	gst_init (&args_length1, &args);
	bindtextdomain (PACKAGE_NAME, LOCALEDIR);
	bind_textdomain_codeset (PACKAGE_NAME, "UTF-8");
	textdomain (PACKAGE_NAME);
	_tmp0_ = g_thread_supported ();
	if (_tmp0_ == FALSE) {
		FILE* _tmp1_ = NULL;
		_tmp1_ = stderr;
		fprintf (_tmp1_, "Threads are not supported!\n");
		result = -1;
		block1_data_unref (_data1_);
		_data1_ = NULL;
		return result;
	}
	_tmp2_ = g_application_new ("com.google.code.p.betaradio", G_APPLICATION_FLAGS_NONE);
	app = _tmp2_;
	_data1_->is_running = FALSE;
	_tmp3_ = app;
	g_signal_connect_data (_tmp3_, "activate", (GCallback) ___lambda2__g_application_activate, block1_data_ref (_data1_), (GClosureNotify) block1_data_unref, 0);
	_tmp4_ = app;
	_tmp5_ = g_application_run (_tmp4_, 0, NULL);
	result = _tmp5_;
	_g_object_unref0 (app);
	block1_data_unref (_data1_);
	_data1_ = NULL;
	return result;
}


int main (int argc, char ** argv) {
	g_thread_init (NULL);
	g_type_init ();
	return beta_radio_main (argv, argc);
}


static void __lambda4_ (BetaRadio* self, GtkCheckMenuItem* e) {
	GtkCheckMenuItem* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	g_return_if_fail (e != NULL);
	_tmp0_ = e;
	_tmp1_ = gtk_check_menu_item_get_active (_tmp0_);
	if (_tmp1_ == TRUE) {
		GstPlayer* _tmp2_ = NULL;
		GstPlayer* _tmp3_ = NULL;
		AnyTrayIcon* _tmp4_ = NULL;
		const gchar* _tmp5_ = NULL;
		_tmp2_ = gst_player_get_instance ();
		_tmp3_ = _tmp2_;
		gst_player_stop (_tmp3_);
		_g_object_unref0 (_tmp3_);
		_tmp4_ = self->priv->icon;
		_tmp5_ = _ ("BetaRadio Tuner");
		any_tray_icon_set_text (_tmp4_, _tmp5_);
	}
}


static void ___lambda4__gtk_check_menu_item_toggled (GtkCheckMenuItem* _sender, gpointer self) {
	__lambda4_ (self, _sender);
}


static void __lambda7_ (BetaRadio* self, GtkCheckMenuItem* e) {
	GtkCheckMenuItem* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	g_return_if_fail (e != NULL);
	_tmp0_ = e;
	_tmp1_ = gtk_check_menu_item_get_active (_tmp0_);
	if (_tmp1_ == TRUE) {
		GstPlayer* _tmp2_ = NULL;
		GstPlayer* _tmp3_ = NULL;
		AnyTrayIcon* _tmp4_ = NULL;
		const gchar* _tmp5_ = NULL;
		_tmp2_ = gst_player_get_instance ();
		_tmp3_ = _tmp2_;
		gst_player_stop (_tmp3_);
		_g_object_unref0 (_tmp3_);
		_tmp4_ = self->priv->icon;
		_tmp5_ = _ ("BetaRadio Tuner");
		any_tray_icon_set_text (_tmp4_, _tmp5_);
		gtk_main_quit ();
	}
}


static void ___lambda7__gtk_check_menu_item_toggled (GtkCheckMenuItem* _sender, gpointer self) {
	__lambda7_ (self, _sender);
}


static void* ___lambda3_ (BetaRadio* self) {
	void* result = NULL;
	GtkMenu* _tmp0_ = NULL;
	GSList* group = NULL;
	GtkRadioMenuItem* stop = NULL;
	GSList* _tmp1_ = NULL;
	const gchar* _tmp2_ = NULL;
	GtkRadioMenuItem* _tmp3_ = NULL;
	GSList* _tmp4_ = NULL;
	GtkMenu* _tmp5_ = NULL;
	GtkMenu* _tmp6_ = NULL;
	GtkSeparatorMenuItem* _tmp7_ = NULL;
	GtkSeparatorMenuItem* _tmp8_ = NULL;
	GtkMenu* _tmp9_ = NULL;
	GSList* _tmp10_ = NULL;
	GSList* _tmp11_ = NULL;
	GtkMenu* _tmp12_ = NULL;
	GtkSeparatorMenuItem* _tmp13_ = NULL;
	GtkSeparatorMenuItem* _tmp14_ = NULL;
	GtkRadioMenuItem* quit = NULL;
	GSList* _tmp15_ = NULL;
	const gchar* _tmp16_ = NULL;
	GtkRadioMenuItem* _tmp17_ = NULL;
	GSList* _tmp18_ = NULL;
	GtkMenu* _tmp19_ = NULL;
	GtkMenu* _tmp20_ = NULL;
	AnyTrayIcon* _tmp21_ = NULL;
	GtkMenu* _tmp22_ = NULL;
	AnyTrayIcon* _tmp23_ = NULL;
	const gchar* _tmp24_ = NULL;
	_tmp0_ = (GtkMenu*) gtk_menu_new ();
	g_object_ref_sink (_tmp0_);
	_g_object_unref0 (self->priv->menu);
	self->priv->menu = _tmp0_;
	group = NULL;
	_tmp1_ = group;
	_tmp2_ = _ ("Stop");
	_tmp3_ = (GtkRadioMenuItem*) gtk_radio_menu_item_new_with_label (_tmp1_, _tmp2_);
	g_object_ref_sink (_tmp3_);
	stop = _tmp3_;
	_tmp4_ = gtk_radio_menu_item_get_group (stop);
	group = _tmp4_;
	_tmp5_ = self->priv->menu;
	gtk_menu_shell_append ((GtkMenuShell*) _tmp5_, (GtkWidget*) ((GtkMenuItem*) stop));
	g_signal_connect_object ((GtkCheckMenuItem*) stop, "toggled", (GCallback) ___lambda4__gtk_check_menu_item_toggled, self, 0);
	_tmp6_ = self->priv->menu;
	_tmp7_ = (GtkSeparatorMenuItem*) gtk_separator_menu_item_new ();
	g_object_ref_sink (_tmp7_);
	_tmp8_ = _tmp7_;
	gtk_menu_shell_append ((GtkMenuShell*) _tmp6_, (GtkWidget*) ((GtkMenuItem*) _tmp8_));
	_g_object_unref0 (_tmp8_);
	_tmp9_ = self->priv->menu;
	_tmp10_ = group;
	_tmp11_ = beta_radio_getMenu (self, _tmp9_, _tmp10_);
	group = _tmp11_;
	_tmp12_ = self->priv->menu;
	_tmp13_ = (GtkSeparatorMenuItem*) gtk_separator_menu_item_new ();
	g_object_ref_sink (_tmp13_);
	_tmp14_ = _tmp13_;
	gtk_menu_shell_append ((GtkMenuShell*) _tmp12_, (GtkWidget*) ((GtkMenuItem*) _tmp14_));
	_g_object_unref0 (_tmp14_);
	_tmp15_ = group;
	_tmp16_ = _ ("Quit");
	_tmp17_ = (GtkRadioMenuItem*) gtk_radio_menu_item_new_with_label (_tmp15_, _tmp16_);
	g_object_ref_sink (_tmp17_);
	quit = _tmp17_;
	_tmp18_ = gtk_radio_menu_item_get_group (quit);
	group = _tmp18_;
	_tmp19_ = self->priv->menu;
	gtk_menu_shell_append ((GtkMenuShell*) _tmp19_, (GtkWidget*) ((GtkMenuItem*) quit));
	g_signal_connect_object ((GtkCheckMenuItem*) quit, "toggled", (GCallback) ___lambda7__gtk_check_menu_item_toggled, self, 0);
	_tmp20_ = self->priv->menu;
	gtk_widget_show_all ((GtkWidget*) _tmp20_);
	_tmp21_ = self->priv->icon;
	_tmp22_ = self->priv->menu;
	any_tray_icon_set_menu (_tmp21_, _tmp22_);
	_tmp23_ = self->priv->icon;
	_tmp24_ = _ ("BetaRadio Tuner");
	any_tray_icon_set_text (_tmp23_, _tmp24_);
	result = NULL;
	_g_object_unref0 (quit);
	_g_object_unref0 (stop);
	return result;
}


static gpointer ____lambda3__gthread_func (gpointer self) {
	gpointer result;
	result = ___lambda3_ (self);
	g_object_unref (self);
	return result;
}


BetaRadio* beta_radio_construct (GType object_type) {
	BetaRadio * self = NULL;
	const gchar* _tmp0_ = NULL;
	AnyTrayIcon* _tmp1_ = NULL;
	AnyTrayIcon* _tmp2_ = NULL;
	const gchar* _tmp3_ = NULL;
	GError * _inner_error_ = NULL;
	self = (BetaRadio*) g_object_new (object_type, NULL);
	_tmp0_ = _ ("BetaRadio Tuner");
	_tmp1_ = any_tray_icon_new (PACKAGE_NAME, _tmp0_);
	_g_object_unref0 (self->priv->icon);
	self->priv->icon = _tmp1_;
	_tmp2_ = self->priv->icon;
	_tmp3_ = _ ("Data Synchronizing ...");
	any_tray_icon_set_text (_tmp2_, _tmp3_);
	{
		g_thread_create (____lambda3__gthread_func, g_object_ref (self), TRUE, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_THREAD_ERROR) {
				goto __catch0_g_thread_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	goto __finally0;
	__catch0_g_thread_error:
	{
		GError* e = NULL;
		GError* _tmp4_ = NULL;
		const gchar* _tmp5_ = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp4_ = e;
		_tmp5_ = _tmp4_->message;
		g_debug ("betaradio.vala:102: %s", _tmp5_);
		_g_error_free0 (e);
	}
	__finally0:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	return self;
}


BetaRadio* beta_radio_new (void) {
	return beta_radio_construct (TYPE_BETA_RADIO);
}


static GSList* beta_radio_getMenu (BetaRadio* self, GtkMenu* menu, GSList* group) {
	GSList* result = NULL;
	JsonSoup* list = NULL;
	JsonSoup* _tmp0_ = NULL;
	JsonSoup* _tmp1_ = NULL;
	gboolean _tmp2_ = FALSE;
	gint length = 0;
	JsonSoup* _tmp8_ = NULL;
	gint _tmp9_ = 0;
	GSList* _tmp58_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (menu != NULL, NULL);
	_tmp0_ = json_soup_new_http ("https://betaradio.googlecode.com/git/utils/list.json");
	list = _tmp0_;
	_tmp1_ = list;
	_tmp2_ = json_soup_is_array (_tmp1_);
	if (_tmp2_ == FALSE) {
		GtkMenuItem* conn_err = NULL;
		const gchar* _tmp3_ = NULL;
		GtkMenuItem* _tmp4_ = NULL;
		GtkMenu* _tmp5_ = NULL;
		GtkMenuItem* _tmp6_ = NULL;
		GSList* _tmp7_ = NULL;
		_tmp3_ = _ ("Connection failed. Please restart this program.");
		_tmp4_ = (GtkMenuItem*) gtk_menu_item_new_with_label (_tmp3_);
		g_object_ref_sink (_tmp4_);
		conn_err = _tmp4_;
		_tmp5_ = menu;
		_tmp6_ = conn_err;
		gtk_menu_shell_append ((GtkMenuShell*) _tmp5_, (GtkWidget*) _tmp6_);
		_tmp7_ = group;
		result = _tmp7_;
		_g_object_unref0 (conn_err);
		_g_object_unref0 (list);
		return result;
	}
	_tmp8_ = list;
	_tmp9_ = json_soup_length (_tmp8_);
	length = _tmp9_;
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp10_ = FALSE;
			_tmp10_ = TRUE;
			while (TRUE) {
				gboolean _tmp11_ = FALSE;
				gint _tmp13_ = 0;
				gint _tmp14_ = 0;
				gchar* feed = NULL;
				JsonSoup* _tmp15_ = NULL;
				gint _tmp16_ = 0;
				JsonSoup* _tmp17_ = NULL;
				gchar* _tmp18_ = NULL;
				JsonSoup* json = NULL;
				const gchar* _tmp19_ = NULL;
				JsonSoup* _tmp20_ = NULL;
				JsonSoup* _tmp21_ = NULL;
				JsonSoup* _tmp22_ = NULL;
				gboolean _tmp23_ = FALSE;
				gchar* title = NULL;
				JsonSoup* _tmp24_ = NULL;
				JsonSoup* _tmp25_ = NULL;
				gchar* _tmp26_ = NULL;
				GtkMenuItem* item = NULL;
				const gchar* _tmp27_ = NULL;
				GtkMenuItem* _tmp28_ = NULL;
				GtkMenu* _tmp29_ = NULL;
				GtkMenuItem* _tmp30_ = NULL;
				GtkMenu* submenu = NULL;
				GtkMenu* _tmp31_ = NULL;
				GtkMenuItem* _tmp32_ = NULL;
				GtkMenu* _tmp33_ = NULL;
				gchar* property = NULL;
				JsonSoup* _tmp34_ = NULL;
				JsonSoup* _tmp35_ = NULL;
				gchar* _tmp36_ = NULL;
				gboolean _tmp37_ = FALSE;
				const gchar* _tmp38_ = NULL;
				gboolean _tmp42_ = FALSE;
				JsonSoup* _tmp57_ = NULL;
				_tmp11_ = _tmp10_;
				if (!_tmp11_) {
					gint _tmp12_ = 0;
					_tmp12_ = i;
					i = _tmp12_ + 1;
				}
				_tmp10_ = FALSE;
				_tmp13_ = i;
				_tmp14_ = length;
				if (!(_tmp13_ < _tmp14_)) {
					break;
				}
				_tmp15_ = list;
				_tmp16_ = i;
				_tmp17_ = json_soup_array (_tmp15_, _tmp16_);
				_tmp18_ = json_soup_get_string (_tmp17_);
				feed = _tmp18_;
				_tmp19_ = feed;
				_tmp20_ = json_soup_new_http (_tmp19_);
				json = _tmp20_;
				_tmp21_ = json;
				_tmp22_ = json_soup_object (_tmp21_, "property");
				_tmp23_ = json_soup_is_string (_tmp22_);
				if (_tmp23_ == FALSE) {
					_g_object_unref0 (json);
					_g_free0 (feed);
					continue;
				}
				_tmp24_ = json;
				_tmp25_ = json_soup_sibling (_tmp24_, "title");
				_tmp26_ = json_soup_get_string (_tmp25_);
				title = _tmp26_;
				_tmp27_ = title;
				_tmp28_ = (GtkMenuItem*) gtk_menu_item_new_with_label (_tmp27_);
				g_object_ref_sink (_tmp28_);
				item = _tmp28_;
				_tmp29_ = menu;
				_tmp30_ = item;
				gtk_menu_shell_append ((GtkMenuShell*) _tmp29_, (GtkWidget*) _tmp30_);
				_tmp31_ = (GtkMenu*) gtk_menu_new ();
				g_object_ref_sink (_tmp31_);
				submenu = _tmp31_;
				_tmp32_ = item;
				_tmp33_ = submenu;
				gtk_menu_item_set_submenu (_tmp32_, (GtkWidget*) _tmp33_);
				_tmp34_ = json;
				_tmp35_ = json_soup_sibling (_tmp34_, "property");
				_tmp36_ = json_soup_get_string (_tmp35_);
				property = _tmp36_;
				_tmp38_ = property;
				if (g_strcmp0 (_tmp38_, "category") == 0) {
					JsonSoup* _tmp39_ = NULL;
					JsonSoup* _tmp40_ = NULL;
					gboolean _tmp41_ = FALSE;
					_tmp39_ = json;
					_tmp40_ = json_soup_sibling (_tmp39_, "category");
					_tmp41_ = json_soup_is_array (_tmp40_);
					_tmp37_ = _tmp41_ == TRUE;
				} else {
					_tmp37_ = FALSE;
				}
				_tmp42_ = _tmp37_;
				if (_tmp42_) {
					GtkMenu* _tmp43_ = NULL;
					GSList* _tmp44_ = NULL;
					JsonSoup* _tmp45_ = NULL;
					GSList* _tmp46_ = NULL;
					_tmp43_ = submenu;
					_tmp44_ = group;
					_tmp45_ = json;
					_tmp46_ = beta_radio_getCategoryMenu (self, _tmp43_, _tmp44_, _tmp45_);
					group = _tmp46_;
				} else {
					gboolean _tmp47_ = FALSE;
					const gchar* _tmp48_ = NULL;
					gboolean _tmp52_ = FALSE;
					_tmp48_ = property;
					if (g_strcmp0 (_tmp48_, "channel") == 0) {
						JsonSoup* _tmp49_ = NULL;
						JsonSoup* _tmp50_ = NULL;
						gboolean _tmp51_ = FALSE;
						_tmp49_ = json;
						_tmp50_ = json_soup_sibling (_tmp49_, "channel");
						_tmp51_ = json_soup_is_array (_tmp50_);
						_tmp47_ = _tmp51_ == TRUE;
					} else {
						_tmp47_ = FALSE;
					}
					_tmp52_ = _tmp47_;
					if (_tmp52_) {
						GtkMenu* _tmp53_ = NULL;
						GSList* _tmp54_ = NULL;
						JsonSoup* _tmp55_ = NULL;
						GSList* _tmp56_ = NULL;
						_tmp53_ = submenu;
						_tmp54_ = group;
						_tmp55_ = json;
						_tmp56_ = beta_radio_getChannelMenu (self, _tmp53_, _tmp54_, _tmp55_);
						group = _tmp56_;
					}
				}
				_tmp57_ = list;
				json_soup_parent (_tmp57_);
				_g_free0 (property);
				_g_object_unref0 (submenu);
				_g_object_unref0 (item);
				_g_free0 (title);
				_g_object_unref0 (json);
				_g_free0 (feed);
			}
		}
	}
	_tmp58_ = group;
	result = _tmp58_;
	_g_object_unref0 (list);
	return result;
}


static Block2Data* block2_data_ref (Block2Data* _data2_) {
	g_atomic_int_inc (&_data2_->_ref_count_);
	return _data2_;
}


static void block2_data_unref (void * _userdata_) {
	Block2Data* _data2_;
	_data2_ = (Block2Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data2_->_ref_count_)) {
		BetaRadio * self;
		self = _data2_->self;
		_g_free0 (_data2_->url);
		_g_free0 (_data2_->title);
		_g_object_unref0 (self);
		g_slice_free (Block2Data, _data2_);
	}
}


static void ________lambda5_ (Block2Data* _data2_, GtkCheckMenuItem* e) {
	BetaRadio * self;
	GtkCheckMenuItem* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	self = _data2_->self;
	g_return_if_fail (e != NULL);
	_tmp0_ = e;
	_tmp1_ = gtk_check_menu_item_get_active (_tmp0_);
	if (_tmp1_ == TRUE) {
		GstPlayer* _tmp2_ = NULL;
		GstPlayer* _tmp3_ = NULL;
		const gchar* _tmp4_ = NULL;
		const gchar* _tmp5_ = NULL;
		AnyTrayIcon* _tmp6_ = NULL;
		const gchar* _tmp7_ = NULL;
		_tmp2_ = gst_player_get_instance ();
		_tmp3_ = _tmp2_;
		_tmp4_ = _data2_->title;
		_tmp5_ = _data2_->url;
		gst_player_play (_tmp3_, _tmp4_, _tmp5_);
		_g_object_unref0 (_tmp3_);
		_tmp6_ = self->priv->icon;
		_tmp7_ = _data2_->title;
		any_tray_icon_set_text (_tmp6_, _tmp7_);
	}
}


static void _________lambda5__gtk_check_menu_item_toggled (GtkCheckMenuItem* _sender, gpointer self) {
	________lambda5_ (self, _sender);
}


static GSList* beta_radio_getCategoryMenu (BetaRadio* self, GtkMenu* menu, GSList* group, JsonSoup* json) {
	GSList* result = NULL;
	gint length = 0;
	JsonSoup* _tmp0_ = NULL;
	gint _tmp1_ = 0;
	GSList* _tmp52_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (menu != NULL, NULL);
	g_return_val_if_fail (json != NULL, NULL);
	_tmp0_ = json;
	_tmp1_ = json_soup_length (_tmp0_);
	length = _tmp1_;
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp2_ = FALSE;
			_tmp2_ = TRUE;
			while (TRUE) {
				gboolean _tmp3_ = FALSE;
				gint _tmp5_ = 0;
				gint _tmp6_ = 0;
				gchar* category = NULL;
				JsonSoup* _tmp7_ = NULL;
				gint _tmp8_ = 0;
				JsonSoup* _tmp9_ = NULL;
				JsonSoup* _tmp10_ = NULL;
				gchar* _tmp11_ = NULL;
				GtkMenuItem* item = NULL;
				const gchar* _tmp12_ = NULL;
				GtkMenuItem* _tmp13_ = NULL;
				GtkMenu* submenu = NULL;
				GtkMenu* _tmp14_ = NULL;
				GtkMenu* _tmp15_ = NULL;
				GtkMenuItem* _tmp16_ = NULL;
				GtkMenuItem* _tmp17_ = NULL;
				GtkMenu* _tmp18_ = NULL;
				gint size = 0;
				JsonSoup* _tmp19_ = NULL;
				JsonSoup* _tmp20_ = NULL;
				gint _tmp21_ = 0;
				JsonSoup* _tmp51_ = NULL;
				_tmp3_ = _tmp2_;
				if (!_tmp3_) {
					gint _tmp4_ = 0;
					_tmp4_ = i;
					i = _tmp4_ + 1;
				}
				_tmp2_ = FALSE;
				_tmp5_ = i;
				_tmp6_ = length;
				if (!(_tmp5_ < _tmp6_)) {
					break;
				}
				_tmp7_ = json;
				_tmp8_ = i;
				_tmp9_ = json_soup_array (_tmp7_, _tmp8_);
				_tmp10_ = json_soup_object (_tmp9_, "title");
				_tmp11_ = json_soup_get_string (_tmp10_);
				category = _tmp11_;
				_tmp12_ = category;
				_tmp13_ = (GtkMenuItem*) gtk_menu_item_new_with_label (_tmp12_);
				g_object_ref_sink (_tmp13_);
				item = _tmp13_;
				_tmp14_ = (GtkMenu*) gtk_menu_new ();
				g_object_ref_sink (_tmp14_);
				submenu = _tmp14_;
				_tmp15_ = menu;
				_tmp16_ = item;
				gtk_menu_shell_append ((GtkMenuShell*) _tmp15_, (GtkWidget*) _tmp16_);
				_tmp17_ = item;
				_tmp18_ = submenu;
				gtk_menu_item_set_submenu (_tmp17_, (GtkWidget*) _tmp18_);
				_tmp19_ = json;
				_tmp20_ = json_soup_sibling (_tmp19_, "channel");
				_tmp21_ = json_soup_length (_tmp20_);
				size = _tmp21_;
				{
					gint j = 0;
					j = 0;
					{
						gboolean _tmp22_ = FALSE;
						_tmp22_ = TRUE;
						while (TRUE) {
							Block2Data* _data2_;
							gboolean _tmp23_ = FALSE;
							gint _tmp25_ = 0;
							gint _tmp26_ = 0;
							JsonSoup* _tmp27_ = NULL;
							gint _tmp28_ = 0;
							JsonSoup* _tmp29_ = NULL;
							JsonSoup* _tmp30_ = NULL;
							gchar* _tmp31_ = NULL;
							gchar* type = NULL;
							JsonSoup* _tmp32_ = NULL;
							JsonSoup* _tmp33_ = NULL;
							gchar* _tmp34_ = NULL;
							JsonSoup* _tmp35_ = NULL;
							JsonSoup* _tmp36_ = NULL;
							gchar* _tmp37_ = NULL;
							gchar* _tmp38_ = NULL;
							const gchar* _tmp39_ = NULL;
							gchar* _tmp40_ = NULL;
							gchar* _tmp41_ = NULL;
							GtkRadioMenuItem* radio = NULL;
							GSList* _tmp42_ = NULL;
							const gchar* _tmp43_ = NULL;
							GtkRadioMenuItem* _tmp44_ = NULL;
							GtkRadioMenuItem* _tmp45_ = NULL;
							GSList* _tmp46_ = NULL;
							GtkMenu* _tmp47_ = NULL;
							GtkRadioMenuItem* _tmp48_ = NULL;
							GtkRadioMenuItem* _tmp49_ = NULL;
							JsonSoup* _tmp50_ = NULL;
							_data2_ = g_slice_new0 (Block2Data);
							_data2_->_ref_count_ = 1;
							_data2_->self = g_object_ref (self);
							_tmp23_ = _tmp22_;
							if (!_tmp23_) {
								gint _tmp24_ = 0;
								_tmp24_ = j;
								j = _tmp24_ + 1;
							}
							_tmp22_ = FALSE;
							_tmp25_ = j;
							_tmp26_ = size;
							if (!(_tmp25_ < _tmp26_)) {
								block2_data_unref (_data2_);
								_data2_ = NULL;
								break;
							}
							_tmp27_ = json;
							_tmp28_ = j;
							_tmp29_ = json_soup_array (_tmp27_, _tmp28_);
							_tmp30_ = json_soup_object (_tmp29_, "title");
							_tmp31_ = json_soup_get_string (_tmp30_);
							_data2_->title = _tmp31_;
							_tmp32_ = json;
							_tmp33_ = json_soup_sibling (_tmp32_, "type");
							_tmp34_ = json_soup_get_string (_tmp33_);
							type = _tmp34_;
							_tmp35_ = json;
							_tmp36_ = json_soup_sibling (_tmp35_, "url");
							_tmp37_ = json_soup_get_string (_tmp36_);
							_tmp38_ = _tmp37_;
							_tmp39_ = type;
							_tmp40_ = beta_radio_filter_url (self, _tmp38_, _tmp39_);
							_tmp41_ = _tmp40_;
							_g_free0 (_tmp38_);
							_data2_->url = _tmp41_;
							_tmp42_ = group;
							_tmp43_ = _data2_->title;
							_tmp44_ = (GtkRadioMenuItem*) gtk_radio_menu_item_new_with_label (_tmp42_, _tmp43_);
							g_object_ref_sink (_tmp44_);
							radio = _tmp44_;
							_tmp45_ = radio;
							_tmp46_ = gtk_radio_menu_item_get_group (_tmp45_);
							group = _tmp46_;
							_tmp47_ = submenu;
							_tmp48_ = radio;
							gtk_menu_shell_append ((GtkMenuShell*) _tmp47_, (GtkWidget*) ((GtkMenuItem*) _tmp48_));
							_tmp49_ = radio;
							g_signal_connect_data ((GtkCheckMenuItem*) _tmp49_, "toggled", (GCallback) _________lambda5__gtk_check_menu_item_toggled, block2_data_ref (_data2_), (GClosureNotify) block2_data_unref, 0);
							_tmp50_ = json;
							json_soup_grandparent (_tmp50_);
							_g_object_unref0 (radio);
							_g_free0 (type);
							block2_data_unref (_data2_);
							_data2_ = NULL;
						}
					}
				}
				_tmp51_ = json;
				json_soup_grandparent (_tmp51_);
				_g_object_unref0 (submenu);
				_g_object_unref0 (item);
				_g_free0 (category);
			}
		}
	}
	_tmp52_ = group;
	result = _tmp52_;
	return result;
}


static Block3Data* block3_data_ref (Block3Data* _data3_) {
	g_atomic_int_inc (&_data3_->_ref_count_);
	return _data3_;
}


static void block3_data_unref (void * _userdata_) {
	Block3Data* _data3_;
	_data3_ = (Block3Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data3_->_ref_count_)) {
		BetaRadio * self;
		self = _data3_->self;
		_g_free0 (_data3_->url);
		_g_free0 (_data3_->title);
		_g_object_unref0 (self);
		g_slice_free (Block3Data, _data3_);
	}
}


static void _____lambda6_ (Block3Data* _data3_, GtkCheckMenuItem* e) {
	BetaRadio * self;
	GtkCheckMenuItem* _tmp0_ = NULL;
	gboolean _tmp1_ = FALSE;
	self = _data3_->self;
	g_return_if_fail (e != NULL);
	_tmp0_ = e;
	_tmp1_ = gtk_check_menu_item_get_active (_tmp0_);
	if (_tmp1_ == TRUE) {
		GstPlayer* _tmp2_ = NULL;
		GstPlayer* _tmp3_ = NULL;
		const gchar* _tmp4_ = NULL;
		const gchar* _tmp5_ = NULL;
		AnyTrayIcon* _tmp6_ = NULL;
		const gchar* _tmp7_ = NULL;
		_tmp2_ = gst_player_get_instance ();
		_tmp3_ = _tmp2_;
		_tmp4_ = _data3_->title;
		_tmp5_ = _data3_->url;
		gst_player_play (_tmp3_, _tmp4_, _tmp5_);
		_g_object_unref0 (_tmp3_);
		_tmp6_ = self->priv->icon;
		_tmp7_ = _data3_->title;
		any_tray_icon_set_text (_tmp6_, _tmp7_);
	}
}


static void ______lambda6__gtk_check_menu_item_toggled (GtkCheckMenuItem* _sender, gpointer self) {
	_____lambda6_ (self, _sender);
}


static GSList* beta_radio_getChannelMenu (BetaRadio* self, GtkMenu* menu, GSList* group, JsonSoup* json) {
	GSList* result = NULL;
	gint length = 0;
	JsonSoup* _tmp0_ = NULL;
	gint _tmp1_ = 0;
	GSList* _tmp31_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (menu != NULL, NULL);
	g_return_val_if_fail (json != NULL, NULL);
	_tmp0_ = json;
	_tmp1_ = json_soup_length (_tmp0_);
	length = _tmp1_;
	{
		gint i = 0;
		i = 0;
		{
			gboolean _tmp2_ = FALSE;
			_tmp2_ = TRUE;
			while (TRUE) {
				Block3Data* _data3_;
				gboolean _tmp3_ = FALSE;
				gint _tmp5_ = 0;
				gint _tmp6_ = 0;
				JsonSoup* _tmp7_ = NULL;
				gint _tmp8_ = 0;
				JsonSoup* _tmp9_ = NULL;
				JsonSoup* _tmp10_ = NULL;
				gchar* _tmp11_ = NULL;
				gchar* type = NULL;
				JsonSoup* _tmp12_ = NULL;
				JsonSoup* _tmp13_ = NULL;
				gchar* _tmp14_ = NULL;
				JsonSoup* _tmp15_ = NULL;
				JsonSoup* _tmp16_ = NULL;
				gchar* _tmp17_ = NULL;
				gchar* _tmp18_ = NULL;
				const gchar* _tmp19_ = NULL;
				gchar* _tmp20_ = NULL;
				gchar* _tmp21_ = NULL;
				GtkRadioMenuItem* radio = NULL;
				GSList* _tmp22_ = NULL;
				const gchar* _tmp23_ = NULL;
				GtkRadioMenuItem* _tmp24_ = NULL;
				GtkRadioMenuItem* _tmp25_ = NULL;
				GSList* _tmp26_ = NULL;
				GtkMenu* _tmp27_ = NULL;
				GtkRadioMenuItem* _tmp28_ = NULL;
				GtkRadioMenuItem* _tmp29_ = NULL;
				JsonSoup* _tmp30_ = NULL;
				_data3_ = g_slice_new0 (Block3Data);
				_data3_->_ref_count_ = 1;
				_data3_->self = g_object_ref (self);
				_tmp3_ = _tmp2_;
				if (!_tmp3_) {
					gint _tmp4_ = 0;
					_tmp4_ = i;
					i = _tmp4_ + 1;
				}
				_tmp2_ = FALSE;
				_tmp5_ = i;
				_tmp6_ = length;
				if (!(_tmp5_ < _tmp6_)) {
					block3_data_unref (_data3_);
					_data3_ = NULL;
					break;
				}
				_tmp7_ = json;
				_tmp8_ = i;
				_tmp9_ = json_soup_array (_tmp7_, _tmp8_);
				_tmp10_ = json_soup_object (_tmp9_, "title");
				_tmp11_ = json_soup_get_string (_tmp10_);
				_data3_->title = _tmp11_;
				_tmp12_ = json;
				_tmp13_ = json_soup_sibling (_tmp12_, "type");
				_tmp14_ = json_soup_get_string (_tmp13_);
				type = _tmp14_;
				_tmp15_ = json;
				_tmp16_ = json_soup_sibling (_tmp15_, "url");
				_tmp17_ = json_soup_get_string (_tmp16_);
				_tmp18_ = _tmp17_;
				_tmp19_ = type;
				_tmp20_ = beta_radio_filter_url (self, _tmp18_, _tmp19_);
				_tmp21_ = _tmp20_;
				_g_free0 (_tmp18_);
				_data3_->url = _tmp21_;
				_tmp22_ = group;
				_tmp23_ = _data3_->title;
				_tmp24_ = (GtkRadioMenuItem*) gtk_radio_menu_item_new_with_label (_tmp22_, _tmp23_);
				g_object_ref_sink (_tmp24_);
				radio = _tmp24_;
				_tmp25_ = radio;
				_tmp26_ = gtk_radio_menu_item_get_group (_tmp25_);
				group = _tmp26_;
				_tmp27_ = menu;
				_tmp28_ = radio;
				gtk_menu_shell_append ((GtkMenuShell*) _tmp27_, (GtkWidget*) ((GtkMenuItem*) _tmp28_));
				_tmp29_ = radio;
				g_signal_connect_data ((GtkCheckMenuItem*) _tmp29_, "toggled", (GCallback) ______lambda6__gtk_check_menu_item_toggled, block3_data_ref (_data3_), (GClosureNotify) block3_data_unref, 0);
				_tmp30_ = json;
				json_soup_grandparent (_tmp30_);
				_g_object_unref0 (radio);
				_g_free0 (type);
				block3_data_unref (_data3_);
				_data3_ = NULL;
			}
		}
	}
	_tmp31_ = group;
	result = _tmp31_;
	return result;
}


static gchar* string_replace (const gchar* self, const gchar* old, const gchar* replacement) {
	gchar* result = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (old != NULL, NULL);
	g_return_val_if_fail (replacement != NULL, NULL);
	{
		GRegex* regex = NULL;
		const gchar* _tmp0_ = NULL;
		gchar* _tmp1_ = NULL;
		gchar* _tmp2_ = NULL;
		GRegex* _tmp3_ = NULL;
		GRegex* _tmp4_ = NULL;
		gchar* _tmp5_ = NULL;
		GRegex* _tmp6_ = NULL;
		const gchar* _tmp7_ = NULL;
		gchar* _tmp8_ = NULL;
		_tmp0_ = old;
		_tmp1_ = g_regex_escape_string (_tmp0_, -1);
		_tmp2_ = _tmp1_;
		_tmp3_ = g_regex_new (_tmp2_, 0, 0, &_inner_error_);
		_tmp4_ = _tmp3_;
		_g_free0 (_tmp2_);
		regex = _tmp4_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch1_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp6_ = regex;
		_tmp7_ = replacement;
		_tmp8_ = g_regex_replace_literal (_tmp6_, self, (gssize) (-1), 0, _tmp7_, 0, &_inner_error_);
		_tmp5_ = _tmp8_;
		if (_inner_error_ != NULL) {
			_g_regex_unref0 (regex);
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch1_g_regex_error;
			}
			_g_regex_unref0 (regex);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		result = _tmp5_;
		_g_regex_unref0 (regex);
		return result;
	}
	goto __finally1;
	__catch1_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally1:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
}


static gchar* beta_radio_filter_url (BetaRadio* self, const gchar* url, const gchar* type) {
	gchar* result = NULL;
	gboolean _tmp0_ = FALSE;
	const gchar* _tmp1_ = NULL;
	gboolean _tmp4_ = FALSE;
	const gchar* _tmp10_ = NULL;
	gchar* _tmp11_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (url != NULL, NULL);
	g_return_val_if_fail (type != NULL, NULL);
	_tmp1_ = type;
	if (g_strcmp0 (_tmp1_, "mms") == 0) {
		const gchar* _tmp2_ = NULL;
		gboolean _tmp3_ = FALSE;
		_tmp2_ = url;
		_tmp3_ = g_str_has_prefix (_tmp2_, "http://");
		_tmp0_ = _tmp3_ == TRUE;
	} else {
		_tmp0_ = FALSE;
	}
	_tmp4_ = _tmp0_;
	if (_tmp4_) {
		const gchar* _tmp5_ = NULL;
		gchar* _tmp6_ = NULL;
		gchar* _tmp7_ = NULL;
		gchar* _tmp8_ = NULL;
		gchar* _tmp9_ = NULL;
		_tmp5_ = url;
		_tmp6_ = string_replace (_tmp5_, "http", "mmsh");
		_tmp7_ = _tmp6_;
		_tmp8_ = g_strconcat (_tmp7_, "\\?MSWMExt\\=.asf", NULL);
		_tmp9_ = _tmp8_;
		_g_free0 (_tmp7_);
		result = _tmp9_;
		return result;
	}
	_tmp10_ = url;
	_tmp11_ = g_strdup (_tmp10_);
	result = _tmp11_;
	return result;
}


static void beta_radio_class_init (BetaRadioClass * klass) {
	beta_radio_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (BetaRadioPrivate));
	G_OBJECT_CLASS (klass)->finalize = beta_radio_finalize;
}


static void beta_radio_instance_init (BetaRadio * self) {
	self->priv = BETA_RADIO_GET_PRIVATE (self);
	self->priv->menu = NULL;
	self->priv->icon = NULL;
}


static void beta_radio_finalize (GObject* obj) {
	BetaRadio * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_BETA_RADIO, BetaRadio);
	_g_object_unref0 (self->priv->menu);
	_g_object_unref0 (self->priv->icon);
	G_OBJECT_CLASS (beta_radio_parent_class)->finalize (obj);
}


/**
 * Copyright (C) 2010 Shih-Yuan Lee (FourDollars) <fourdollars@gmail.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
GType beta_radio_get_type (void) {
	static volatile gsize beta_radio_type_id__volatile = 0;
	if (g_once_init_enter (&beta_radio_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (BetaRadioClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) beta_radio_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (BetaRadio), 0, (GInstanceInitFunc) beta_radio_instance_init, NULL };
		GType beta_radio_type_id;
		beta_radio_type_id = g_type_register_static (G_TYPE_OBJECT, "BetaRadio", &g_define_type_info, 0);
		g_once_init_leave (&beta_radio_type_id__volatile, beta_radio_type_id);
	}
	return beta_radio_type_id__volatile;
}



