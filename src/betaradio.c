/* betaradio.c generated by valac 0.16.1, the Vala compiler
 * generated from betaradio.vala, do not modify */

/* -*- coding: utf-8; indent-tabs-mode: nil; tab-width: 4; c-basic-offset: 4; -*- */
/* vim:set fileencodings=utf-8 tabstop=4 expandtab shiftwidth=4 softtabstop=4: */

#include <glib.h>
#include <glib-object.h>
#include <any_tray_icon.h>
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>
#include <gdk/gdk.h>
#include <gst/gst.h>
#include <glib/gi18n-lib.h>
#include <config.h>
#include <gio/gio.h>


#define TYPE_BETA_RADIO (beta_radio_get_type ())
#define BETA_RADIO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_BETA_RADIO, BetaRadio))
#define BETA_RADIO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_BETA_RADIO, BetaRadioClass))
#define IS_BETA_RADIO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_BETA_RADIO))
#define IS_BETA_RADIO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_BETA_RADIO))
#define BETA_RADIO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_BETA_RADIO, BetaRadioClass))

typedef struct _BetaRadio BetaRadio;
typedef struct _BetaRadioClass BetaRadioClass;
typedef struct _BetaRadioPrivate BetaRadioPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
typedef struct _Block1Data Block1Data;

#define TYPE_GST_PLAYER (gst_player_get_type ())
#define GST_PLAYER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GST_PLAYER, GstPlayer))
#define GST_PLAYER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GST_PLAYER, GstPlayerClass))
#define IS_GST_PLAYER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GST_PLAYER))
#define IS_GST_PLAYER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GST_PLAYER))
#define GST_PLAYER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GST_PLAYER, GstPlayerClass))

typedef struct _GstPlayer GstPlayer;
typedef struct _GstPlayerClass GstPlayerClass;
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

#define TYPE_JSON_SOUP (json_soup_get_type ())
#define JSON_SOUP(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_JSON_SOUP, JsonSoup))
#define JSON_SOUP_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_JSON_SOUP, JsonSoupClass))
#define IS_JSON_SOUP(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_JSON_SOUP))
#define IS_JSON_SOUP_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_JSON_SOUP))
#define JSON_SOUP_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_JSON_SOUP, JsonSoupClass))

typedef struct _JsonSoup JsonSoup;
typedef struct _JsonSoupClass JsonSoupClass;
#define _g_free0(var) (var = (g_free (var), NULL))
typedef struct _Block2Data Block2Data;
typedef struct _Block3Data Block3Data;
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))

struct _BetaRadio {
	GObject parent_instance;
	BetaRadioPrivate * priv;
};

struct _BetaRadioClass {
	GObjectClass parent_class;
};

struct _BetaRadioPrivate {
	AnyTrayIcon* icon;
	GtkMenu* menu;
};

struct _Block1Data {
	int _ref_count_;
	gboolean is_running;
};

struct _Block2Data {
	int _ref_count_;
	BetaRadio * self;
	gchar* title;
	gchar* url;
};

struct _Block3Data {
	int _ref_count_;
	BetaRadio * self;
	gchar* title;
	gchar* url;
};


static gpointer beta_radio_parent_class = NULL;

GType beta_radio_get_type (void) G_GNUC_CONST;
#define BETA_RADIO_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_BETA_RADIO, BetaRadioPrivate))
enum  {
	BETA_RADIO_DUMMY_PROPERTY
};
gint beta_radio_main (gchar** args, int args_length1);
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (void * _userdata_);
static void __lambda2_ (Block1Data* _data1_);
BetaRadio* beta_radio_new (void);
BetaRadio* beta_radio_construct (GType object_type);
static void ___lambda2__g_application_activate (GApplication* _sender, gpointer self);
static void* ___lambda3_ (BetaRadio* self);
static void __lambda4_ (BetaRadio* self, GtkCheckMenuItem* e);
GType gst_player_get_type (void) G_GNUC_CONST;
GstPlayer* gst_player_get_instance (void);
void gst_player_stop (GstPlayer* self);
static void ___lambda4__gtk_check_menu_item_toggled (GtkCheckMenuItem* _sender, gpointer self);
static GSList* beta_radio_getMenu (BetaRadio* self, GtkMenu* menu, GSList* group);
static void __lambda7_ (BetaRadio* self, GtkCheckMenuItem* e);
static void ___lambda7__gtk_check_menu_item_toggled (GtkCheckMenuItem* _sender, gpointer self);
static gpointer ____lambda3__gthread_func (gpointer self);
JsonSoup* json_soup_new_http (const gchar* url);
JsonSoup* json_soup_construct_http (GType object_type, const gchar* url);
GType json_soup_get_type (void) G_GNUC_CONST;
gboolean json_soup_is_array (JsonSoup* self);
gint json_soup_length (JsonSoup* self);
JsonSoup* json_soup_array (JsonSoup* self, gint idx);
gchar* json_soup_get_string (JsonSoup* self);
JsonSoup* json_soup_object (JsonSoup* self, const gchar* name);
gboolean json_soup_is_string (JsonSoup* self);
JsonSoup* json_soup_sibling (JsonSoup* self, const gchar* name);
static GSList* beta_radio_getCategoryMenu (BetaRadio* self, GtkMenu* menu, GSList* group, JsonSoup* json);
static GSList* beta_radio_getChannelMenu (BetaRadio* self, GtkMenu* menu, GSList* group, JsonSoup* json);
JsonSoup* json_soup_parent (JsonSoup* self);
static Block2Data* block2_data_ref (Block2Data* _data2_);
static void block2_data_unref (void * _userdata_);
static gchar* beta_radio_filter_url (BetaRadio* self, const gchar* url, const gchar* type);
static void ________lambda5_ (Block2Data* _data2_, GtkCheckMenuItem* e);
void gst_player_play (GstPlayer* self, const gchar* url);
static void _________lambda5__gtk_check_menu_item_toggled (GtkCheckMenuItem* _sender, gpointer self);
JsonSoup* json_soup_grandparent (JsonSoup* self);
static Block3Data* block3_data_ref (Block3Data* _data3_);
static void block3_data_unref (void * _userdata_);
static void _____lambda6_ (Block3Data* _data3_, GtkCheckMenuItem* e);
static void ______lambda6__gtk_check_menu_item_toggled (GtkCheckMenuItem* _sender, gpointer self);
static void beta_radio_finalize (GObject* obj);


static Block1Data* block1_data_ref (Block1Data* _data1_) {
	g_atomic_int_inc (&_data1_->_ref_count_);
	return _data1_;
}


static void block1_data_unref (void * _userdata_) {
	Block1Data* _data1_;
	_data1_ = (Block1Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data1_->_ref_count_)) {
		g_slice_free (Block1Data, _data1_);
	}
}


static void __lambda2_ (Block1Data* _data1_) {
	BetaRadio* _tmp0_;
	BetaRadio* instance;
	if (_data1_->is_running) {
		return;
	}
	_data1_->is_running = TRUE;
	gdk_threads_enter ();
	_tmp0_ = beta_radio_new ();
	instance = _tmp0_;
	gtk_main ();
	gdk_threads_leave ();
	_g_object_unref0 (instance);
}


static void ___lambda2__g_application_activate (GApplication* _sender, gpointer self) {
	__lambda2_ (self);
}


gint beta_radio_main (gchar** args, int args_length1) {
	gint result = 0;
	Block1Data* _data1_;
	GApplication* _tmp0_;
	GApplication* app;
	gint _tmp1_ = 0;
	_data1_ = g_slice_new0 (Block1Data);
	_data1_->_ref_count_ = 1;
	gdk_threads_init ();
	gst_init (&args_length1, &args);
	gtk_init (&args_length1, &args);
	bindtextdomain (PACKAGE_NAME, LOCALEDIR);
	bind_textdomain_codeset (PACKAGE_NAME, "UTF-8");
	textdomain (PACKAGE_NAME);
	_tmp0_ = g_application_new ("org.sylee.betaradio", G_APPLICATION_FLAGS_NONE);
	app = _tmp0_;
	_data1_->is_running = FALSE;
	g_signal_connect_data (app, "activate", (GCallback) ___lambda2__g_application_activate, block1_data_ref (_data1_), (GClosureNotify) block1_data_unref, 0);
	_tmp1_ = g_application_run (app, 0, NULL);
	result = _tmp1_;
	_g_object_unref0 (app);
	block1_data_unref (_data1_);
	_data1_ = NULL;
	return result;
}


int main (int argc, char ** argv) {
	g_thread_init (NULL);
	g_type_init ();
	return beta_radio_main (argv, argc);
}


static void __lambda4_ (BetaRadio* self, GtkCheckMenuItem* e) {
	GtkCheckMenuItem* _tmp0_;
	gboolean _tmp1_ = FALSE;
	g_return_if_fail (e != NULL);
	_tmp0_ = e;
	_tmp1_ = gtk_check_menu_item_get_active (_tmp0_);
	if (_tmp1_ == TRUE) {
		GstPlayer* _tmp2_ = NULL;
		GstPlayer* _tmp3_;
		AnyTrayIcon* _tmp4_;
		const gchar* _tmp5_ = NULL;
		_tmp2_ = gst_player_get_instance ();
		_tmp3_ = _tmp2_;
		gst_player_stop (_tmp3_);
		_g_object_unref0 (_tmp3_);
		_tmp4_ = self->priv->icon;
		_tmp5_ = _ ("BetaRadio Tuner");
		any_tray_icon_set_text (_tmp4_, _tmp5_);
	}
}


static void ___lambda4__gtk_check_menu_item_toggled (GtkCheckMenuItem* _sender, gpointer self) {
	__lambda4_ (self, _sender);
}


static void __lambda7_ (BetaRadio* self, GtkCheckMenuItem* e) {
	GtkCheckMenuItem* _tmp0_;
	gboolean _tmp1_ = FALSE;
	g_return_if_fail (e != NULL);
	_tmp0_ = e;
	_tmp1_ = gtk_check_menu_item_get_active (_tmp0_);
	if (_tmp1_ == TRUE) {
		GstPlayer* _tmp2_ = NULL;
		GstPlayer* _tmp3_;
		AnyTrayIcon* _tmp4_;
		const gchar* _tmp5_ = NULL;
		_tmp2_ = gst_player_get_instance ();
		_tmp3_ = _tmp2_;
		gst_player_stop (_tmp3_);
		_g_object_unref0 (_tmp3_);
		_tmp4_ = self->priv->icon;
		_tmp5_ = _ ("BetaRadio Tuner");
		any_tray_icon_set_text (_tmp4_, _tmp5_);
		gtk_main_quit ();
	}
}


static void ___lambda7__gtk_check_menu_item_toggled (GtkCheckMenuItem* _sender, gpointer self) {
	__lambda7_ (self, _sender);
}


static void* ___lambda3_ (BetaRadio* self) {
	void* result = NULL;
	GtkMenu* _tmp0_;
	GtkMenu* _tmp1_;
	GSList* group;
	GSList* _tmp2_;
	const gchar* _tmp3_ = NULL;
	GtkRadioMenuItem* _tmp4_;
	GtkRadioMenuItem* _tmp5_;
	GtkRadioMenuItem* stop;
	GSList* _tmp6_ = NULL;
	GtkMenu* _tmp7_;
	GtkMenu* _tmp8_;
	GtkSeparatorMenuItem* _tmp9_;
	GtkSeparatorMenuItem* _tmp10_;
	GtkMenu* _tmp11_;
	GSList* _tmp12_;
	GSList* _tmp13_ = NULL;
	GtkMenu* _tmp14_;
	GtkSeparatorMenuItem* _tmp15_;
	GtkSeparatorMenuItem* _tmp16_;
	GSList* _tmp17_;
	const gchar* _tmp18_ = NULL;
	GtkRadioMenuItem* _tmp19_;
	GtkRadioMenuItem* _tmp20_;
	GtkRadioMenuItem* quit;
	GSList* _tmp21_ = NULL;
	GtkMenu* _tmp22_;
	GtkMenu* _tmp23_;
	AnyTrayIcon* _tmp24_;
	GtkMenu* _tmp25_;
	AnyTrayIcon* _tmp26_;
	const gchar* _tmp27_ = NULL;
	gdk_threads_enter ();
	_tmp0_ = (GtkMenu*) gtk_menu_new ();
	_tmp1_ = g_object_ref_sink (_tmp0_);
	_g_object_unref0 (self->priv->menu);
	self->priv->menu = _tmp1_;
	group = NULL;
	_tmp2_ = group;
	_tmp3_ = _ ("Stop");
	_tmp4_ = (GtkRadioMenuItem*) gtk_radio_menu_item_new_with_label (_tmp2_, _tmp3_);
	_tmp5_ = g_object_ref_sink (_tmp4_);
	stop = _tmp5_;
	_tmp6_ = gtk_radio_menu_item_get_group (stop);
	group = _tmp6_;
	_tmp7_ = self->priv->menu;
	gtk_menu_shell_append ((GtkMenuShell*) _tmp7_, (GtkWidget*) ((GtkMenuItem*) stop));
	g_signal_connect_object ((GtkCheckMenuItem*) stop, "toggled", (GCallback) ___lambda4__gtk_check_menu_item_toggled, self, 0);
	_tmp8_ = self->priv->menu;
	_tmp9_ = (GtkSeparatorMenuItem*) gtk_separator_menu_item_new ();
	_tmp10_ = g_object_ref_sink (_tmp9_);
	gtk_menu_shell_append ((GtkMenuShell*) _tmp8_, (GtkWidget*) ((GtkMenuItem*) _tmp10_));
	_g_object_unref0 (_tmp10_);
	_tmp11_ = self->priv->menu;
	_tmp12_ = group;
	_tmp13_ = beta_radio_getMenu (self, _tmp11_, _tmp12_);
	group = _tmp13_;
	_tmp14_ = self->priv->menu;
	_tmp15_ = (GtkSeparatorMenuItem*) gtk_separator_menu_item_new ();
	_tmp16_ = g_object_ref_sink (_tmp15_);
	gtk_menu_shell_append ((GtkMenuShell*) _tmp14_, (GtkWidget*) ((GtkMenuItem*) _tmp16_));
	_g_object_unref0 (_tmp16_);
	_tmp17_ = group;
	_tmp18_ = _ ("Quit");
	_tmp19_ = (GtkRadioMenuItem*) gtk_radio_menu_item_new_with_label (_tmp17_, _tmp18_);
	_tmp20_ = g_object_ref_sink (_tmp19_);
	quit = _tmp20_;
	_tmp21_ = gtk_radio_menu_item_get_group (quit);
	group = _tmp21_;
	_tmp22_ = self->priv->menu;
	gtk_menu_shell_append ((GtkMenuShell*) _tmp22_, (GtkWidget*) ((GtkMenuItem*) quit));
	g_signal_connect_object ((GtkCheckMenuItem*) quit, "toggled", (GCallback) ___lambda7__gtk_check_menu_item_toggled, self, 0);
	_tmp23_ = self->priv->menu;
	gtk_widget_show_all ((GtkWidget*) _tmp23_);
	_tmp24_ = self->priv->icon;
	_tmp25_ = self->priv->menu;
	any_tray_icon_set_menu (_tmp24_, _tmp25_);
	_tmp26_ = self->priv->icon;
	_tmp27_ = _ ("BetaRadio Tuner");
	any_tray_icon_set_text (_tmp26_, _tmp27_);
	gdk_threads_leave ();
	result = NULL;
	_g_object_unref0 (quit);
	_g_object_unref0 (stop);
	return result;
}


static gpointer ____lambda3__gthread_func (gpointer self) {
	gpointer result;
	result = ___lambda3_ (self);
	return result;
}


BetaRadio* beta_radio_construct (GType object_type) {
	BetaRadio * self = NULL;
	const gchar* _tmp0_ = NULL;
	AnyTrayIcon* _tmp1_;
	AnyTrayIcon* _tmp2_;
	const gchar* _tmp3_ = NULL;
	GError * _inner_error_ = NULL;
	self = (BetaRadio*) g_object_new (object_type, NULL);
	_tmp0_ = _ ("BetaRadio Tuner");
	_tmp1_ = any_tray_icon_new (PACKAGE_NAME, _tmp0_);
	_g_object_unref0 (self->priv->icon);
	self->priv->icon = _tmp1_;
	_tmp2_ = self->priv->icon;
	_tmp3_ = _ ("Data Synchronizing ...");
	any_tray_icon_set_text (_tmp2_, _tmp3_);
	{
		g_thread_create (____lambda3__gthread_func, self, TRUE, &_inner_error_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_THREAD_ERROR) {
				goto __catch0_g_thread_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
	}
	goto __finally0;
	__catch0_g_thread_error:
	{
		GError* e = NULL;
		GError* _tmp4_;
		const gchar* _tmp5_;
		e = _inner_error_;
		_inner_error_ = NULL;
		_tmp4_ = e;
		_tmp5_ = _tmp4_->message;
		g_debug ("betaradio.vala:99: %s", _tmp5_);
		_g_error_free0 (e);
	}
	__finally0:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
	return self;
}


BetaRadio* beta_radio_new (void) {
	return beta_radio_construct (TYPE_BETA_RADIO);
}


static GSList* beta_radio_getMenu (BetaRadio* self, GtkMenu* menu, GSList* group) {
	GSList* result = NULL;
	JsonSoup* _tmp0_;
	JsonSoup* list;
	JsonSoup* _tmp1_;
	gboolean _tmp2_ = FALSE;
	JsonSoup* _tmp9_;
	gint _tmp10_ = 0;
	gint length;
	GSList* _tmp61_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (menu != NULL, NULL);
	_tmp0_ = json_soup_new_http ("http://betaradio.googlecode.com/svn/trunk/utils/list.json");
	list = _tmp0_;
	_tmp1_ = list;
	_tmp2_ = json_soup_is_array (_tmp1_);
	if (_tmp2_ == FALSE) {
		const gchar* _tmp3_ = NULL;
		GtkMenuItem* _tmp4_;
		GtkMenuItem* _tmp5_;
		GtkMenuItem* conn_err;
		GtkMenu* _tmp6_;
		GtkMenuItem* _tmp7_;
		GSList* _tmp8_;
		_tmp3_ = _ ("Connection failed. Please restart this program.");
		_tmp4_ = (GtkMenuItem*) gtk_menu_item_new_with_label (_tmp3_);
		_tmp5_ = g_object_ref_sink (_tmp4_);
		conn_err = _tmp5_;
		_tmp6_ = menu;
		_tmp7_ = conn_err;
		gtk_menu_shell_append ((GtkMenuShell*) _tmp6_, (GtkWidget*) _tmp7_);
		_tmp8_ = group;
		result = _tmp8_;
		_g_object_unref0 (conn_err);
		_g_object_unref0 (list);
		return result;
	}
	_tmp9_ = list;
	_tmp10_ = json_soup_length (_tmp9_);
	length = _tmp10_;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp11_;
			_tmp11_ = TRUE;
			while (TRUE) {
				gboolean _tmp12_;
				gint _tmp14_;
				gint _tmp15_;
				JsonSoup* _tmp16_;
				gint _tmp17_;
				JsonSoup* _tmp18_ = NULL;
				gchar* _tmp19_ = NULL;
				gchar* feed;
				const gchar* _tmp20_;
				JsonSoup* _tmp21_;
				JsonSoup* json;
				JsonSoup* _tmp22_;
				JsonSoup* _tmp23_ = NULL;
				gboolean _tmp24_ = FALSE;
				JsonSoup* _tmp25_;
				JsonSoup* _tmp26_ = NULL;
				gchar* _tmp27_ = NULL;
				gchar* title;
				const gchar* _tmp28_;
				GtkMenuItem* _tmp29_;
				GtkMenuItem* _tmp30_;
				GtkMenuItem* item;
				GtkMenu* _tmp31_;
				GtkMenuItem* _tmp32_;
				GtkMenu* _tmp33_;
				GtkMenu* _tmp34_;
				GtkMenu* submenu;
				GtkMenuItem* _tmp35_;
				GtkMenu* _tmp36_;
				JsonSoup* _tmp37_;
				JsonSoup* _tmp38_ = NULL;
				gchar* _tmp39_ = NULL;
				gchar* property;
				gboolean _tmp40_ = FALSE;
				const gchar* _tmp41_;
				gboolean _tmp45_;
				JsonSoup* _tmp60_;
				_tmp12_ = _tmp11_;
				if (!_tmp12_) {
					gint _tmp13_;
					_tmp13_ = i;
					i = _tmp13_ + 1;
				}
				_tmp11_ = FALSE;
				_tmp14_ = i;
				_tmp15_ = length;
				if (!(_tmp14_ < _tmp15_)) {
					break;
				}
				_tmp16_ = list;
				_tmp17_ = i;
				_tmp18_ = json_soup_array (_tmp16_, _tmp17_);
				_tmp19_ = json_soup_get_string (_tmp18_);
				feed = _tmp19_;
				_tmp20_ = feed;
				_tmp21_ = json_soup_new_http (_tmp20_);
				json = _tmp21_;
				_tmp22_ = json;
				_tmp23_ = json_soup_object (_tmp22_, "property");
				_tmp24_ = json_soup_is_string (_tmp23_);
				if (_tmp24_ == FALSE) {
					_g_object_unref0 (json);
					_g_free0 (feed);
					continue;
				}
				_tmp25_ = json;
				_tmp26_ = json_soup_sibling (_tmp25_, "title");
				_tmp27_ = json_soup_get_string (_tmp26_);
				title = _tmp27_;
				_tmp28_ = title;
				_tmp29_ = (GtkMenuItem*) gtk_menu_item_new_with_label (_tmp28_);
				_tmp30_ = g_object_ref_sink (_tmp29_);
				item = _tmp30_;
				_tmp31_ = menu;
				_tmp32_ = item;
				gtk_menu_shell_append ((GtkMenuShell*) _tmp31_, (GtkWidget*) _tmp32_);
				_tmp33_ = (GtkMenu*) gtk_menu_new ();
				_tmp34_ = g_object_ref_sink (_tmp33_);
				submenu = _tmp34_;
				_tmp35_ = item;
				_tmp36_ = submenu;
				gtk_menu_item_set_submenu (_tmp35_, (GtkWidget*) _tmp36_);
				_tmp37_ = json;
				_tmp38_ = json_soup_sibling (_tmp37_, "property");
				_tmp39_ = json_soup_get_string (_tmp38_);
				property = _tmp39_;
				_tmp41_ = property;
				if (g_strcmp0 (_tmp41_, "category") == 0) {
					JsonSoup* _tmp42_;
					JsonSoup* _tmp43_ = NULL;
					gboolean _tmp44_ = FALSE;
					_tmp42_ = json;
					_tmp43_ = json_soup_sibling (_tmp42_, "category");
					_tmp44_ = json_soup_is_array (_tmp43_);
					_tmp40_ = _tmp44_ == TRUE;
				} else {
					_tmp40_ = FALSE;
				}
				_tmp45_ = _tmp40_;
				if (_tmp45_) {
					GtkMenu* _tmp46_;
					GSList* _tmp47_;
					JsonSoup* _tmp48_;
					GSList* _tmp49_ = NULL;
					_tmp46_ = submenu;
					_tmp47_ = group;
					_tmp48_ = json;
					_tmp49_ = beta_radio_getCategoryMenu (self, _tmp46_, _tmp47_, _tmp48_);
					group = _tmp49_;
				} else {
					gboolean _tmp50_ = FALSE;
					const gchar* _tmp51_;
					gboolean _tmp55_;
					_tmp51_ = property;
					if (g_strcmp0 (_tmp51_, "channel") == 0) {
						JsonSoup* _tmp52_;
						JsonSoup* _tmp53_ = NULL;
						gboolean _tmp54_ = FALSE;
						_tmp52_ = json;
						_tmp53_ = json_soup_sibling (_tmp52_, "channel");
						_tmp54_ = json_soup_is_array (_tmp53_);
						_tmp50_ = _tmp54_ == TRUE;
					} else {
						_tmp50_ = FALSE;
					}
					_tmp55_ = _tmp50_;
					if (_tmp55_) {
						GtkMenu* _tmp56_;
						GSList* _tmp57_;
						JsonSoup* _tmp58_;
						GSList* _tmp59_ = NULL;
						_tmp56_ = submenu;
						_tmp57_ = group;
						_tmp58_ = json;
						_tmp59_ = beta_radio_getChannelMenu (self, _tmp56_, _tmp57_, _tmp58_);
						group = _tmp59_;
					}
				}
				_tmp60_ = list;
				json_soup_parent (_tmp60_);
				_g_free0 (property);
				_g_object_unref0 (submenu);
				_g_object_unref0 (item);
				_g_free0 (title);
				_g_object_unref0 (json);
				_g_free0 (feed);
			}
		}
	}
	_tmp61_ = group;
	result = _tmp61_;
	_g_object_unref0 (list);
	return result;
}


static Block2Data* block2_data_ref (Block2Data* _data2_) {
	g_atomic_int_inc (&_data2_->_ref_count_);
	return _data2_;
}


static void block2_data_unref (void * _userdata_) {
	Block2Data* _data2_;
	_data2_ = (Block2Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data2_->_ref_count_)) {
		BetaRadio * self;
		self = _data2_->self;
		_g_free0 (_data2_->url);
		_g_free0 (_data2_->title);
		_g_object_unref0 (self);
		g_slice_free (Block2Data, _data2_);
	}
}


static void ________lambda5_ (Block2Data* _data2_, GtkCheckMenuItem* e) {
	BetaRadio * self;
	GtkCheckMenuItem* _tmp0_;
	gboolean _tmp1_ = FALSE;
	self = _data2_->self;
	g_return_if_fail (e != NULL);
	_tmp0_ = e;
	_tmp1_ = gtk_check_menu_item_get_active (_tmp0_);
	if (_tmp1_ == TRUE) {
		GstPlayer* _tmp2_ = NULL;
		GstPlayer* _tmp3_;
		const gchar* _tmp4_;
		AnyTrayIcon* _tmp5_;
		const gchar* _tmp6_;
		_tmp2_ = gst_player_get_instance ();
		_tmp3_ = _tmp2_;
		_tmp4_ = _data2_->url;
		gst_player_play (_tmp3_, _tmp4_);
		_g_object_unref0 (_tmp3_);
		_tmp5_ = self->priv->icon;
		_tmp6_ = _data2_->title;
		any_tray_icon_set_text (_tmp5_, _tmp6_);
	}
}


static void _________lambda5__gtk_check_menu_item_toggled (GtkCheckMenuItem* _sender, gpointer self) {
	________lambda5_ (self, _sender);
}


static GSList* beta_radio_getCategoryMenu (BetaRadio* self, GtkMenu* menu, GSList* group, JsonSoup* json) {
	GSList* result = NULL;
	JsonSoup* _tmp0_;
	gint _tmp1_ = 0;
	gint length;
	GSList* _tmp55_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (menu != NULL, NULL);
	g_return_val_if_fail (json != NULL, NULL);
	_tmp0_ = json;
	_tmp1_ = json_soup_length (_tmp0_);
	length = _tmp1_;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp2_;
			_tmp2_ = TRUE;
			while (TRUE) {
				gboolean _tmp3_;
				gint _tmp5_;
				gint _tmp6_;
				JsonSoup* _tmp7_;
				gint _tmp8_;
				JsonSoup* _tmp9_ = NULL;
				JsonSoup* _tmp10_ = NULL;
				gchar* _tmp11_ = NULL;
				gchar* category;
				const gchar* _tmp12_;
				GtkMenuItem* _tmp13_;
				GtkMenuItem* _tmp14_;
				GtkMenuItem* item;
				GtkMenu* _tmp15_;
				GtkMenu* _tmp16_;
				GtkMenu* submenu;
				GtkMenu* _tmp17_;
				GtkMenuItem* _tmp18_;
				GtkMenuItem* _tmp19_;
				GtkMenu* _tmp20_;
				JsonSoup* _tmp21_;
				JsonSoup* _tmp22_ = NULL;
				gint _tmp23_ = 0;
				gint size;
				JsonSoup* _tmp54_;
				_tmp3_ = _tmp2_;
				if (!_tmp3_) {
					gint _tmp4_;
					_tmp4_ = i;
					i = _tmp4_ + 1;
				}
				_tmp2_ = FALSE;
				_tmp5_ = i;
				_tmp6_ = length;
				if (!(_tmp5_ < _tmp6_)) {
					break;
				}
				_tmp7_ = json;
				_tmp8_ = i;
				_tmp9_ = json_soup_array (_tmp7_, _tmp8_);
				_tmp10_ = json_soup_object (_tmp9_, "title");
				_tmp11_ = json_soup_get_string (_tmp10_);
				category = _tmp11_;
				_tmp12_ = category;
				_tmp13_ = (GtkMenuItem*) gtk_menu_item_new_with_label (_tmp12_);
				_tmp14_ = g_object_ref_sink (_tmp13_);
				item = _tmp14_;
				_tmp15_ = (GtkMenu*) gtk_menu_new ();
				_tmp16_ = g_object_ref_sink (_tmp15_);
				submenu = _tmp16_;
				_tmp17_ = menu;
				_tmp18_ = item;
				gtk_menu_shell_append ((GtkMenuShell*) _tmp17_, (GtkWidget*) _tmp18_);
				_tmp19_ = item;
				_tmp20_ = submenu;
				gtk_menu_item_set_submenu (_tmp19_, (GtkWidget*) _tmp20_);
				_tmp21_ = json;
				_tmp22_ = json_soup_sibling (_tmp21_, "channel");
				_tmp23_ = json_soup_length (_tmp22_);
				size = _tmp23_;
				{
					gint j;
					j = 0;
					{
						gboolean _tmp24_;
						_tmp24_ = TRUE;
						while (TRUE) {
							Block2Data* _data2_;
							gboolean _tmp25_;
							gint _tmp27_;
							gint _tmp28_;
							JsonSoup* _tmp29_;
							gint _tmp30_;
							JsonSoup* _tmp31_ = NULL;
							JsonSoup* _tmp32_ = NULL;
							gchar* _tmp33_ = NULL;
							JsonSoup* _tmp34_;
							JsonSoup* _tmp35_ = NULL;
							gchar* _tmp36_ = NULL;
							gchar* type;
							JsonSoup* _tmp37_;
							JsonSoup* _tmp38_ = NULL;
							gchar* _tmp39_ = NULL;
							gchar* _tmp40_;
							const gchar* _tmp41_;
							gchar* _tmp42_ = NULL;
							gchar* _tmp43_;
							GSList* _tmp44_;
							const gchar* _tmp45_;
							GtkRadioMenuItem* _tmp46_;
							GtkRadioMenuItem* _tmp47_;
							GtkRadioMenuItem* radio;
							GtkRadioMenuItem* _tmp48_;
							GSList* _tmp49_ = NULL;
							GtkMenu* _tmp50_;
							GtkRadioMenuItem* _tmp51_;
							GtkRadioMenuItem* _tmp52_;
							JsonSoup* _tmp53_;
							_data2_ = g_slice_new0 (Block2Data);
							_data2_->_ref_count_ = 1;
							_data2_->self = g_object_ref (self);
							_tmp25_ = _tmp24_;
							if (!_tmp25_) {
								gint _tmp26_;
								_tmp26_ = j;
								j = _tmp26_ + 1;
							}
							_tmp24_ = FALSE;
							_tmp27_ = j;
							_tmp28_ = size;
							if (!(_tmp27_ < _tmp28_)) {
								block2_data_unref (_data2_);
								_data2_ = NULL;
								break;
							}
							_tmp29_ = json;
							_tmp30_ = j;
							_tmp31_ = json_soup_array (_tmp29_, _tmp30_);
							_tmp32_ = json_soup_object (_tmp31_, "title");
							_tmp33_ = json_soup_get_string (_tmp32_);
							_data2_->title = _tmp33_;
							_tmp34_ = json;
							_tmp35_ = json_soup_sibling (_tmp34_, "type");
							_tmp36_ = json_soup_get_string (_tmp35_);
							type = _tmp36_;
							_tmp37_ = json;
							_tmp38_ = json_soup_sibling (_tmp37_, "url");
							_tmp39_ = json_soup_get_string (_tmp38_);
							_tmp40_ = _tmp39_;
							_tmp41_ = type;
							_tmp42_ = beta_radio_filter_url (self, _tmp40_, _tmp41_);
							_tmp43_ = _tmp42_;
							_g_free0 (_tmp40_);
							_data2_->url = _tmp43_;
							_tmp44_ = group;
							_tmp45_ = _data2_->title;
							_tmp46_ = (GtkRadioMenuItem*) gtk_radio_menu_item_new_with_label (_tmp44_, _tmp45_);
							_tmp47_ = g_object_ref_sink (_tmp46_);
							radio = _tmp47_;
							_tmp48_ = radio;
							_tmp49_ = gtk_radio_menu_item_get_group (_tmp48_);
							group = _tmp49_;
							_tmp50_ = submenu;
							_tmp51_ = radio;
							gtk_menu_shell_append ((GtkMenuShell*) _tmp50_, (GtkWidget*) ((GtkMenuItem*) _tmp51_));
							_tmp52_ = radio;
							g_signal_connect_data ((GtkCheckMenuItem*) _tmp52_, "toggled", (GCallback) _________lambda5__gtk_check_menu_item_toggled, block2_data_ref (_data2_), (GClosureNotify) block2_data_unref, 0);
							_tmp53_ = json;
							json_soup_grandparent (_tmp53_);
							_g_object_unref0 (radio);
							_g_free0 (type);
							block2_data_unref (_data2_);
							_data2_ = NULL;
						}
					}
				}
				_tmp54_ = json;
				json_soup_grandparent (_tmp54_);
				_g_object_unref0 (submenu);
				_g_object_unref0 (item);
				_g_free0 (category);
			}
		}
	}
	_tmp55_ = group;
	result = _tmp55_;
	return result;
}


static Block3Data* block3_data_ref (Block3Data* _data3_) {
	g_atomic_int_inc (&_data3_->_ref_count_);
	return _data3_;
}


static void block3_data_unref (void * _userdata_) {
	Block3Data* _data3_;
	_data3_ = (Block3Data*) _userdata_;
	if (g_atomic_int_dec_and_test (&_data3_->_ref_count_)) {
		BetaRadio * self;
		self = _data3_->self;
		_g_free0 (_data3_->url);
		_g_free0 (_data3_->title);
		_g_object_unref0 (self);
		g_slice_free (Block3Data, _data3_);
	}
}


static void _____lambda6_ (Block3Data* _data3_, GtkCheckMenuItem* e) {
	BetaRadio * self;
	GtkCheckMenuItem* _tmp0_;
	gboolean _tmp1_ = FALSE;
	self = _data3_->self;
	g_return_if_fail (e != NULL);
	_tmp0_ = e;
	_tmp1_ = gtk_check_menu_item_get_active (_tmp0_);
	if (_tmp1_ == TRUE) {
		GstPlayer* _tmp2_ = NULL;
		GstPlayer* _tmp3_;
		const gchar* _tmp4_;
		AnyTrayIcon* _tmp5_;
		const gchar* _tmp6_;
		_tmp2_ = gst_player_get_instance ();
		_tmp3_ = _tmp2_;
		_tmp4_ = _data3_->url;
		gst_player_play (_tmp3_, _tmp4_);
		_g_object_unref0 (_tmp3_);
		_tmp5_ = self->priv->icon;
		_tmp6_ = _data3_->title;
		any_tray_icon_set_text (_tmp5_, _tmp6_);
	}
}


static void ______lambda6__gtk_check_menu_item_toggled (GtkCheckMenuItem* _sender, gpointer self) {
	_____lambda6_ (self, _sender);
}


static GSList* beta_radio_getChannelMenu (BetaRadio* self, GtkMenu* menu, GSList* group, JsonSoup* json) {
	GSList* result = NULL;
	JsonSoup* _tmp0_;
	gint _tmp1_ = 0;
	gint length;
	GSList* _tmp32_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (menu != NULL, NULL);
	g_return_val_if_fail (json != NULL, NULL);
	_tmp0_ = json;
	_tmp1_ = json_soup_length (_tmp0_);
	length = _tmp1_;
	{
		gint i;
		i = 0;
		{
			gboolean _tmp2_;
			_tmp2_ = TRUE;
			while (TRUE) {
				Block3Data* _data3_;
				gboolean _tmp3_;
				gint _tmp5_;
				gint _tmp6_;
				JsonSoup* _tmp7_;
				gint _tmp8_;
				JsonSoup* _tmp9_ = NULL;
				JsonSoup* _tmp10_ = NULL;
				gchar* _tmp11_ = NULL;
				JsonSoup* _tmp12_;
				JsonSoup* _tmp13_ = NULL;
				gchar* _tmp14_ = NULL;
				gchar* type;
				JsonSoup* _tmp15_;
				JsonSoup* _tmp16_ = NULL;
				gchar* _tmp17_ = NULL;
				gchar* _tmp18_;
				const gchar* _tmp19_;
				gchar* _tmp20_ = NULL;
				gchar* _tmp21_;
				GSList* _tmp22_;
				const gchar* _tmp23_;
				GtkRadioMenuItem* _tmp24_;
				GtkRadioMenuItem* _tmp25_;
				GtkRadioMenuItem* radio;
				GtkRadioMenuItem* _tmp26_;
				GSList* _tmp27_ = NULL;
				GtkMenu* _tmp28_;
				GtkRadioMenuItem* _tmp29_;
				GtkRadioMenuItem* _tmp30_;
				JsonSoup* _tmp31_;
				_data3_ = g_slice_new0 (Block3Data);
				_data3_->_ref_count_ = 1;
				_data3_->self = g_object_ref (self);
				_tmp3_ = _tmp2_;
				if (!_tmp3_) {
					gint _tmp4_;
					_tmp4_ = i;
					i = _tmp4_ + 1;
				}
				_tmp2_ = FALSE;
				_tmp5_ = i;
				_tmp6_ = length;
				if (!(_tmp5_ < _tmp6_)) {
					block3_data_unref (_data3_);
					_data3_ = NULL;
					break;
				}
				_tmp7_ = json;
				_tmp8_ = i;
				_tmp9_ = json_soup_array (_tmp7_, _tmp8_);
				_tmp10_ = json_soup_object (_tmp9_, "title");
				_tmp11_ = json_soup_get_string (_tmp10_);
				_data3_->title = _tmp11_;
				_tmp12_ = json;
				_tmp13_ = json_soup_sibling (_tmp12_, "type");
				_tmp14_ = json_soup_get_string (_tmp13_);
				type = _tmp14_;
				_tmp15_ = json;
				_tmp16_ = json_soup_sibling (_tmp15_, "url");
				_tmp17_ = json_soup_get_string (_tmp16_);
				_tmp18_ = _tmp17_;
				_tmp19_ = type;
				_tmp20_ = beta_radio_filter_url (self, _tmp18_, _tmp19_);
				_tmp21_ = _tmp20_;
				_g_free0 (_tmp18_);
				_data3_->url = _tmp21_;
				_tmp22_ = group;
				_tmp23_ = _data3_->title;
				_tmp24_ = (GtkRadioMenuItem*) gtk_radio_menu_item_new_with_label (_tmp22_, _tmp23_);
				_tmp25_ = g_object_ref_sink (_tmp24_);
				radio = _tmp25_;
				_tmp26_ = radio;
				_tmp27_ = gtk_radio_menu_item_get_group (_tmp26_);
				group = _tmp27_;
				_tmp28_ = menu;
				_tmp29_ = radio;
				gtk_menu_shell_append ((GtkMenuShell*) _tmp28_, (GtkWidget*) ((GtkMenuItem*) _tmp29_));
				_tmp30_ = radio;
				g_signal_connect_data ((GtkCheckMenuItem*) _tmp30_, "toggled", (GCallback) ______lambda6__gtk_check_menu_item_toggled, block3_data_ref (_data3_), (GClosureNotify) block3_data_unref, 0);
				_tmp31_ = json;
				json_soup_grandparent (_tmp31_);
				_g_object_unref0 (radio);
				_g_free0 (type);
				block3_data_unref (_data3_);
				_data3_ = NULL;
			}
		}
	}
	_tmp32_ = group;
	result = _tmp32_;
	return result;
}


static gchar* string_replace (const gchar* self, const gchar* old, const gchar* replacement) {
	gchar* result = NULL;
	GError * _inner_error_ = NULL;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (old != NULL, NULL);
	g_return_val_if_fail (replacement != NULL, NULL);
	{
		const gchar* _tmp0_;
		gchar* _tmp1_ = NULL;
		gchar* _tmp2_;
		GRegex* _tmp3_;
		GRegex* _tmp4_;
		GRegex* regex;
		GRegex* _tmp5_;
		const gchar* _tmp6_;
		gchar* _tmp7_ = NULL;
		gchar* _tmp8_;
		_tmp0_ = old;
		_tmp1_ = g_regex_escape_string (_tmp0_, -1);
		_tmp2_ = _tmp1_;
		_tmp3_ = g_regex_new (_tmp2_, 0, 0, &_inner_error_);
		_tmp4_ = _tmp3_;
		_g_free0 (_tmp2_);
		regex = _tmp4_;
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch1_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp5_ = regex;
		_tmp6_ = replacement;
		_tmp7_ = g_regex_replace_literal (_tmp5_, self, (gssize) (-1), 0, _tmp6_, 0, &_inner_error_);
		_tmp8_ = _tmp7_;
		if (_inner_error_ != NULL) {
			_g_regex_unref0 (regex);
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch1_g_regex_error;
			}
			_g_regex_unref0 (regex);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		result = _tmp8_;
		_g_regex_unref0 (regex);
		return result;
	}
	goto __finally1;
	__catch1_g_regex_error:
	{
		GError* e = NULL;
		e = _inner_error_;
		_inner_error_ = NULL;
		g_assert_not_reached ();
		_g_error_free0 (e);
	}
	__finally1:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
}


static gchar* beta_radio_filter_url (BetaRadio* self, const gchar* url, const gchar* type) {
	gchar* result = NULL;
	gboolean _tmp0_ = FALSE;
	const gchar* _tmp1_;
	gboolean _tmp4_;
	const gchar* _tmp10_;
	gchar* _tmp11_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (url != NULL, NULL);
	g_return_val_if_fail (type != NULL, NULL);
	_tmp1_ = type;
	if (g_strcmp0 (_tmp1_, "mms") == 0) {
		const gchar* _tmp2_;
		gboolean _tmp3_ = FALSE;
		_tmp2_ = url;
		_tmp3_ = g_str_has_prefix (_tmp2_, "http://");
		_tmp0_ = _tmp3_ == TRUE;
	} else {
		_tmp0_ = FALSE;
	}
	_tmp4_ = _tmp0_;
	if (_tmp4_) {
		const gchar* _tmp5_;
		gchar* _tmp6_ = NULL;
		gchar* _tmp7_;
		gchar* _tmp8_ = NULL;
		gchar* _tmp9_;
		_tmp5_ = url;
		_tmp6_ = string_replace (_tmp5_, "http", "mmsh");
		_tmp7_ = _tmp6_;
		_tmp8_ = g_strconcat (_tmp7_, "\\?MSWMExt\\=.asf", NULL);
		_tmp9_ = _tmp8_;
		_g_free0 (_tmp7_);
		result = _tmp9_;
		return result;
	}
	_tmp10_ = url;
	_tmp11_ = g_strdup (_tmp10_);
	result = _tmp11_;
	return result;
}


static void beta_radio_class_init (BetaRadioClass * klass) {
	beta_radio_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (BetaRadioPrivate));
	G_OBJECT_CLASS (klass)->finalize = beta_radio_finalize;
}


static void beta_radio_instance_init (BetaRadio * self) {
	self->priv = BETA_RADIO_GET_PRIVATE (self);
	self->priv->icon = NULL;
	self->priv->menu = NULL;
}


static void beta_radio_finalize (GObject* obj) {
	BetaRadio * self;
	self = BETA_RADIO (obj);
	_g_object_unref0 (self->priv->icon);
	_g_object_unref0 (self->priv->menu);
	G_OBJECT_CLASS (beta_radio_parent_class)->finalize (obj);
}


/**
 * Copyright (C) 2010 Shih-Yuan Lee (FourDollars) <fourdollars@gmail.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */
GType beta_radio_get_type (void) {
	static volatile gsize beta_radio_type_id__volatile = 0;
	if (g_once_init_enter (&beta_radio_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (BetaRadioClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) beta_radio_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (BetaRadio), 0, (GInstanceInitFunc) beta_radio_instance_init, NULL };
		GType beta_radio_type_id;
		beta_radio_type_id = g_type_register_static (G_TYPE_OBJECT, "BetaRadio", &g_define_type_info, 0);
		g_once_init_leave (&beta_radio_type_id__volatile, beta_radio_type_id);
	}
	return beta_radio_type_id__volatile;
}



