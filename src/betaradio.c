/* betaradio.c generated by valac, the Vala compiler
 * generated from betaradio.vala, do not modify */

/* -*- coding: utf-8; indent-tabs-mode: nil; tab-width: 4; c-basic-offset: 4; -*- */
/* vim:set fileencodings=utf-8 tabstop=4 expandtab shiftwidth=4 softtabstop=4: */

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <glib/gi18n-lib.h>
#include <config.h>
#include <gst/gst.h>
#include <stdlib.h>
#include <string.h>
#include <glib/gstdio.h>
#include <gdk/gdk.h>


#define TYPE_BETA_RADIO (beta_radio_get_type ())
#define BETA_RADIO(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_BETA_RADIO, BetaRadio))
#define BETA_RADIO_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_BETA_RADIO, BetaRadioClass))
#define IS_BETA_RADIO(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_BETA_RADIO))
#define IS_BETA_RADIO_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_BETA_RADIO))
#define BETA_RADIO_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_BETA_RADIO, BetaRadioClass))

typedef struct _BetaRadio BetaRadio;
typedef struct _BetaRadioClass BetaRadioClass;
typedef struct _BetaRadioPrivate BetaRadioPrivate;

#define TYPE_GST_PLAYER (gst_player_get_type ())
#define GST_PLAYER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_GST_PLAYER, GstPlayer))
#define GST_PLAYER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_GST_PLAYER, GstPlayerClass))
#define IS_GST_PLAYER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_GST_PLAYER))
#define IS_GST_PLAYER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_GST_PLAYER))
#define GST_PLAYER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_GST_PLAYER, GstPlayerClass))

typedef struct _GstPlayer GstPlayer;
typedef struct _GstPlayerClass GstPlayerClass;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))

#define TYPE_JSON_SOUP (json_soup_get_type ())
#define JSON_SOUP(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_JSON_SOUP, JsonSoup))
#define JSON_SOUP_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_JSON_SOUP, JsonSoupClass))
#define IS_JSON_SOUP(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_JSON_SOUP))
#define IS_JSON_SOUP_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_JSON_SOUP))
#define JSON_SOUP_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_JSON_SOUP, JsonSoupClass))

typedef struct _JsonSoup JsonSoup;
typedef struct _JsonSoupClass JsonSoupClass;
#define _g_free0(var) (var = (g_free (var), NULL))
typedef struct _Block1Data Block1Data;
typedef struct _Block2Data Block2Data;
#define _g_regex_unref0(var) ((var == NULL) ? NULL : (var = (g_regex_unref (var), NULL)))
#define _g_error_free0(var) ((var == NULL) ? NULL : (var = (g_error_free (var), NULL)))

struct _BetaRadio {
	GObject parent_instance;
	BetaRadioPrivate * priv;
};

struct _BetaRadioClass {
	GObjectClass parent_class;
};

struct _BetaRadioPrivate {
	GtkStatusIcon* icon;
	GtkMenu* menu;
	GstPlayer* player;
};

struct _Block1Data {
	int _ref_count_;
	BetaRadio * self;
	char* title;
	char* url;
};

struct _Block2Data {
	int _ref_count_;
	BetaRadio * self;
	char* title;
	char* url;
};


static gpointer beta_radio_parent_class = NULL;

GType beta_radio_get_type (void);
GType gst_player_get_type (void);
#define BETA_RADIO_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_BETA_RADIO, BetaRadioPrivate))
enum  {
	BETA_RADIO_DUMMY_PROPERTY
};
BetaRadio* beta_radio_new (void);
BetaRadio* beta_radio_construct (GType object_type);
void beta_radio_main (char** args, int args_length1);
void gst_player_stop (GstPlayer* self);
static void _lambda0_ (GtkMenuItem* e, BetaRadio* self);
static void __lambda0__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self);
static GSList* beta_radio_getMenu (BetaRadio* self, GtkMenu* menu, GSList* group);
static void _lambda3_ (GtkMenuItem* e, BetaRadio* self);
static void __lambda3__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self);
static gboolean _lambda4_ (GdkEventButton* e, BetaRadio* self);
static gboolean __lambda4__gtk_status_icon_button_release_event (GtkStatusIcon* _sender, GdkEventButton* event, gpointer self);
JsonSoup* json_soup_new_http (const char* url);
JsonSoup* json_soup_construct_http (GType object_type, const char* url);
GType json_soup_get_type (void);
gboolean json_soup_is_array (JsonSoup* self);
gint json_soup_length (JsonSoup* self);
JsonSoup* json_soup_array (JsonSoup* self, gint idx);
char* json_soup_get_string (JsonSoup* self);
JsonSoup* json_soup_object (JsonSoup* self, const char* name);
gboolean json_soup_is_string (JsonSoup* self);
JsonSoup* json_soup_sibling (JsonSoup* self, const char* name);
static GSList* beta_radio_getCategoryMenu (BetaRadio* self, GtkMenu* menu, GSList* group, JsonSoup* json);
static GSList* beta_radio_getChannelMenu (BetaRadio* self, GtkMenu* menu, GSList* group, JsonSoup* json);
JsonSoup* json_soup_parent (JsonSoup* self);
static char* beta_radio_filter_url (BetaRadio* self, const char* url, const char* type);
GstPlayer* gst_player_new (const char* name, const char* url);
GstPlayer* gst_player_construct (GType object_type, const char* name, const char* url);
void gst_player_play (GstPlayer* self);
static void _lambda1_ (GtkCheckMenuItem* e, Block1Data* _data1_);
static void __lambda1__gtk_check_menu_item_toggled (GtkCheckMenuItem* _sender, gpointer self);
JsonSoup* json_soup_grandparent (JsonSoup* self);
static Block1Data* block1_data_ref (Block1Data* _data1_);
static void block1_data_unref (Block1Data* _data1_);
static void _lambda2_ (GtkCheckMenuItem* e, Block2Data* _data2_);
static void __lambda2__gtk_check_menu_item_toggled (GtkCheckMenuItem* _sender, gpointer self);
static Block2Data* block2_data_ref (Block2Data* _data2_);
static void block2_data_unref (Block2Data* _data2_);
static void beta_radio_finalize (GObject* obj);
static int _vala_strcmp0 (const char * str1, const char * str2);



void beta_radio_main (char** args, int args_length1) {
	BetaRadio* app;
	bindtextdomain (PACKAGE_NAME, LOCALEDIR);
	bind_textdomain_codeset (PACKAGE_NAME, "UTF-8");
	textdomain (PACKAGE_NAME);
	gst_init (&args_length1, &args);
	gtk_init (&args_length1, &args);
	app = beta_radio_new ();
	gtk_main ();
	_g_object_unref0 (app);
}


int main (int argc, char ** argv) {
	g_type_init ();
	beta_radio_main (argv, argc);
	return 0;
}


static void _lambda0_ (GtkMenuItem* e, BetaRadio* self) {
	g_return_if_fail (e != NULL);
	if (self->priv->player != NULL) {
		GstPlayer* _tmp0_;
		gst_player_stop (self->priv->player);
		self->priv->player = (_tmp0_ = NULL, _g_object_unref0 (self->priv->player), _tmp0_);
		gtk_status_icon_set_tooltip_text (self->priv->icon, _ ("BetaRadio Tuner"));
	}
}


static void __lambda0__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self) {
	_lambda0_ (_sender, self);
}


static void _lambda3_ (GtkMenuItem* e, BetaRadio* self) {
	g_return_if_fail (e != NULL);
	if (self->priv->player != NULL) {
		GstPlayer* _tmp0_;
		gst_player_stop (self->priv->player);
		self->priv->player = (_tmp0_ = NULL, _g_object_unref0 (self->priv->player), _tmp0_);
		gtk_status_icon_set_tooltip_text (self->priv->icon, _ ("BetaRadio Tuner"));
	}
	gtk_main_quit ();
}


static void __lambda3__gtk_menu_item_activate (GtkMenuItem* _sender, gpointer self) {
	_lambda3_ (_sender, self);
}


static gboolean _lambda4_ (GdkEventButton* e, BetaRadio* self) {
	gboolean result = FALSE;
	gtk_menu_popup (self->priv->menu, NULL, NULL, NULL, NULL, (*e).button, (*e).time);
	result = TRUE;
	return result;
}


static gboolean __lambda4__gtk_status_icon_button_release_event (GtkStatusIcon* _sender, GdkEventButton* event, gpointer self) {
	return _lambda4_ (event, self);
}


BetaRadio* beta_radio_construct (GType object_type) {
	BetaRadio * self;
	GtkMenu* _tmp3_;
	GSList* group;
	GtkRadioMenuItem* stop;
	GtkSeparatorMenuItem* _tmp4_;
	GtkSeparatorMenuItem* _tmp5_;
	GtkRadioMenuItem* quit;
	self = (BetaRadio*) g_object_new (object_type, NULL);
	if (g_file_test (DATADIR "/pixmaps/betaradio/betaradio.png", G_FILE_TEST_IS_REGULAR) == TRUE) {
		GtkStatusIcon* _tmp0_;
		self->priv->icon = (_tmp0_ = gtk_status_icon_new_from_file (DATADIR "/pixmaps/betaradio/betaradio.png"), _g_object_unref0 (self->priv->icon), _tmp0_);
	} else {
		if (g_file_test ("data/betaradio.png", G_FILE_TEST_IS_REGULAR) == TRUE) {
			GtkStatusIcon* _tmp1_;
			self->priv->icon = (_tmp1_ = gtk_status_icon_new_from_file ("data/betaradio.png"), _g_object_unref0 (self->priv->icon), _tmp1_);
		} else {
			GtkStatusIcon* _tmp2_;
			self->priv->icon = (_tmp2_ = gtk_status_icon_new_from_stock (GTK_STOCK_MISSING_IMAGE), _g_object_unref0 (self->priv->icon), _tmp2_);
		}
	}
	gtk_status_icon_set_tooltip_text (self->priv->icon, _ ("BetaRadio Tuner"));
	self->priv->menu = (_tmp3_ = g_object_ref_sink ((GtkMenu*) gtk_menu_new ()), _g_object_unref0 (self->priv->menu), _tmp3_);
	group = NULL;
	stop = g_object_ref_sink ((GtkRadioMenuItem*) gtk_radio_menu_item_new_with_label (group, _ ("Stop")));
	group = gtk_radio_menu_item_get_group (stop);
	gtk_menu_shell_append ((GtkMenuShell*) self->priv->menu, (GtkWidget*) ((GtkMenuItem*) stop));
	g_signal_connect_object ((GtkMenuItem*) stop, "activate", (GCallback) __lambda0__gtk_menu_item_activate, self, 0);
	gtk_menu_shell_append ((GtkMenuShell*) self->priv->menu, (GtkWidget*) ((GtkMenuItem*) (_tmp4_ = g_object_ref_sink ((GtkSeparatorMenuItem*) gtk_separator_menu_item_new ()))));
	_g_object_unref0 (_tmp4_);
	group = beta_radio_getMenu (self, self->priv->menu, group);
	gtk_menu_shell_append ((GtkMenuShell*) self->priv->menu, (GtkWidget*) ((GtkMenuItem*) (_tmp5_ = g_object_ref_sink ((GtkSeparatorMenuItem*) gtk_separator_menu_item_new ()))));
	_g_object_unref0 (_tmp5_);
	quit = g_object_ref_sink ((GtkRadioMenuItem*) gtk_radio_menu_item_new_with_label (group, _ ("Quit")));
	group = gtk_radio_menu_item_get_group (stop);
	gtk_menu_shell_append ((GtkMenuShell*) self->priv->menu, (GtkWidget*) ((GtkMenuItem*) quit));
	g_signal_connect_object ((GtkMenuItem*) quit, "activate", (GCallback) __lambda3__gtk_menu_item_activate, self, 0);
	gtk_widget_show_all ((GtkWidget*) self->priv->menu);
	g_signal_connect_object (self->priv->icon, "button-release-event", (GCallback) __lambda4__gtk_status_icon_button_release_event, self, 0);
	_g_object_unref0 (stop);
	_g_object_unref0 (quit);
	return self;
}


BetaRadio* beta_radio_new (void) {
	return beta_radio_construct (TYPE_BETA_RADIO);
}


static GSList* beta_radio_getMenu (BetaRadio* self, GtkMenu* menu, GSList* group) {
	GSList* result = NULL;
	JsonSoup* list;
	gint length;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (menu != NULL, NULL);
	list = json_soup_new_http ("http://betaradio.googlecode.com/svn/trunk/utils/list.json");
	if (json_soup_is_array (list) == FALSE) {
		result = group;
		_g_object_unref0 (list);
		return result;
	}
	length = json_soup_length (list);
	{
		gint i;
		i = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				JsonSoup* _tmp1_;
				char* _tmp2_;
				char* feed;
				JsonSoup* json;
				JsonSoup* _tmp3_;
				gboolean _tmp4_;
				JsonSoup* _tmp5_;
				char* _tmp6_;
				char* title;
				GtkMenuItem* item;
				GtkMenu* submenu;
				JsonSoup* _tmp7_;
				char* _tmp8_;
				char* property;
				gboolean _tmp9_ = FALSE;
				JsonSoup* _tmp13_;
				if (!_tmp0_) {
					i++;
				}
				_tmp0_ = FALSE;
				if (!(i < length)) {
					break;
				}
				feed = (_tmp2_ = json_soup_get_string (_tmp1_ = json_soup_array (list, i)), _g_object_unref0 (_tmp1_), _tmp2_);
				json = json_soup_new_http (feed);
				if ((_tmp4_ = json_soup_is_string (_tmp3_ = json_soup_object (json, "property")) == FALSE, _g_object_unref0 (_tmp3_), _tmp4_)) {
					_g_free0 (feed);
					_g_object_unref0 (json);
					continue;
				}
				title = (_tmp6_ = json_soup_get_string (_tmp5_ = json_soup_sibling (json, "title")), _g_object_unref0 (_tmp5_), _tmp6_);
				item = g_object_ref_sink ((GtkMenuItem*) gtk_menu_item_new_with_label (title));
				gtk_menu_shell_append ((GtkMenuShell*) menu, (GtkWidget*) item);
				submenu = g_object_ref_sink ((GtkMenu*) gtk_menu_new ());
				gtk_menu_item_set_submenu (item, (GtkWidget*) submenu);
				property = (_tmp8_ = json_soup_get_string (_tmp7_ = json_soup_sibling (json, "property")), _g_object_unref0 (_tmp7_), _tmp8_);
				if (_vala_strcmp0 (property, "category") == 0) {
					JsonSoup* _tmp10_;
					_tmp9_ = json_soup_is_array (_tmp10_ = json_soup_sibling (json, "category")) == TRUE;
					_g_object_unref0 (_tmp10_);
				} else {
					_tmp9_ = FALSE;
				}
				if (_tmp9_) {
					group = beta_radio_getCategoryMenu (self, submenu, group, json);
				} else {
					gboolean _tmp11_ = FALSE;
					if (_vala_strcmp0 (property, "channel") == 0) {
						JsonSoup* _tmp12_;
						_tmp11_ = json_soup_is_array (_tmp12_ = json_soup_sibling (json, "channel")) == TRUE;
						_g_object_unref0 (_tmp12_);
					} else {
						_tmp11_ = FALSE;
					}
					if (_tmp11_) {
						group = beta_radio_getChannelMenu (self, submenu, group, json);
					}
				}
				_tmp13_ = json_soup_parent (list);
				_g_object_unref0 (_tmp13_);
				_g_free0 (feed);
				_g_object_unref0 (json);
				_g_free0 (title);
				_g_object_unref0 (item);
				_g_object_unref0 (submenu);
				_g_free0 (property);
			}
		}
	}
	result = group;
	_g_object_unref0 (list);
	return result;
}


static void _lambda1_ (GtkCheckMenuItem* e, Block1Data* _data1_) {
	BetaRadio * self;
	GstPlayer* _tmp0_;
	self = _data1_->self;
	g_return_if_fail (e != NULL);
	if (self->priv->player != NULL) {
		gst_player_stop (self->priv->player);
	}
	self->priv->player = (_tmp0_ = gst_player_new ("BetaRadio", _data1_->url), _g_object_unref0 (self->priv->player), _tmp0_);
	gst_player_play (self->priv->player);
	gtk_status_icon_set_tooltip_text (self->priv->icon, _data1_->title);
}


static void __lambda1__gtk_check_menu_item_toggled (GtkCheckMenuItem* _sender, gpointer self) {
	_lambda1_ (_sender, self);
}


static Block1Data* block1_data_ref (Block1Data* _data1_) {
	++_data1_->_ref_count_;
	return _data1_;
}


static void block1_data_unref (Block1Data* _data1_) {
	if ((--_data1_->_ref_count_) == 0) {
		_g_object_unref0 (_data1_->self);
		_g_free0 (_data1_->title);
		_g_free0 (_data1_->url);
		g_slice_free (Block1Data, _data1_);
	}
}


static GSList* beta_radio_getCategoryMenu (BetaRadio* self, GtkMenu* menu, GSList* group, JsonSoup* json) {
	GSList* result = NULL;
	gint length;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (menu != NULL, NULL);
	g_return_val_if_fail (json != NULL, NULL);
	length = json_soup_length (json);
	{
		gint i;
		i = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				JsonSoup* _tmp2_;
				JsonSoup* _tmp1_;
				char* _tmp3_;
				char* category;
				GtkMenuItem* item;
				GtkMenu* submenu;
				JsonSoup* _tmp4_;
				gint _tmp5_;
				gint size;
				JsonSoup* _tmp16_;
				if (!_tmp0_) {
					i++;
				}
				_tmp0_ = FALSE;
				if (!(i < length)) {
					break;
				}
				category = (_tmp3_ = json_soup_get_string (_tmp2_ = json_soup_object (_tmp1_ = json_soup_array (json, i), "title")), _g_object_unref0 (_tmp2_), _g_object_unref0 (_tmp1_), _tmp3_);
				item = g_object_ref_sink ((GtkMenuItem*) gtk_menu_item_new_with_label (category));
				submenu = g_object_ref_sink ((GtkMenu*) gtk_menu_new ());
				gtk_menu_shell_append ((GtkMenuShell*) menu, (GtkWidget*) item);
				gtk_menu_item_set_submenu (item, (GtkWidget*) submenu);
				size = (_tmp5_ = json_soup_length (_tmp4_ = json_soup_sibling (json, "channel")), _g_object_unref0 (_tmp4_), _tmp5_);
				{
					gint j;
					j = 0;
					{
						gboolean _tmp6_;
						_tmp6_ = TRUE;
						while (TRUE) {
							Block1Data* _data1_;
							JsonSoup* _tmp8_;
							JsonSoup* _tmp7_;
							char* _tmp9_;
							JsonSoup* _tmp10_;
							char* _tmp11_;
							char* type;
							char* _tmp13_;
							JsonSoup* _tmp12_;
							char* _tmp14_;
							GtkRadioMenuItem* radio;
							JsonSoup* _tmp15_;
							_data1_ = g_slice_new0 (Block1Data);
							_data1_->_ref_count_ = 1;
							_data1_->self = g_object_ref (self);
							if (!_tmp6_) {
								j++;
							}
							_tmp6_ = FALSE;
							if (!(j < size)) {
								block1_data_unref (_data1_);
								break;
							}
							_data1_->title = (_tmp9_ = json_soup_get_string (_tmp8_ = json_soup_object (_tmp7_ = json_soup_array (json, j), "title")), _g_object_unref0 (_tmp8_), _g_object_unref0 (_tmp7_), _tmp9_);
							type = (_tmp11_ = json_soup_get_string (_tmp10_ = json_soup_sibling (json, "type")), _g_object_unref0 (_tmp10_), _tmp11_);
							_data1_->url = (_tmp14_ = beta_radio_filter_url (self, _tmp13_ = json_soup_get_string (_tmp12_ = json_soup_sibling (json, "url")), type), _g_free0 (_tmp13_), _g_object_unref0 (_tmp12_), _tmp14_);
							radio = g_object_ref_sink ((GtkRadioMenuItem*) gtk_radio_menu_item_new_with_label (group, _data1_->title));
							group = gtk_radio_menu_item_get_group (radio);
							g_signal_connect_data ((GtkCheckMenuItem*) radio, "toggled", (GCallback) __lambda1__gtk_check_menu_item_toggled, block1_data_ref (_data1_), (GClosureNotify) block1_data_unref, 0);
							gtk_menu_shell_append ((GtkMenuShell*) submenu, (GtkWidget*) ((GtkMenuItem*) radio));
							_tmp15_ = json_soup_grandparent (json);
							_g_object_unref0 (_tmp15_);
							_g_free0 (type);
							_g_object_unref0 (radio);
							block1_data_unref (_data1_);
						}
					}
				}
				_tmp16_ = json_soup_grandparent (json);
				_g_object_unref0 (_tmp16_);
				_g_free0 (category);
				_g_object_unref0 (item);
				_g_object_unref0 (submenu);
			}
		}
	}
	result = group;
	return result;
}


static void _lambda2_ (GtkCheckMenuItem* e, Block2Data* _data2_) {
	BetaRadio * self;
	GstPlayer* _tmp0_;
	self = _data2_->self;
	g_return_if_fail (e != NULL);
	if (self->priv->player != NULL) {
		gst_player_stop (self->priv->player);
	}
	self->priv->player = (_tmp0_ = gst_player_new ("BetaRadio", _data2_->url), _g_object_unref0 (self->priv->player), _tmp0_);
	gst_player_play (self->priv->player);
	gtk_status_icon_set_tooltip_text (self->priv->icon, _data2_->title);
}


static void __lambda2__gtk_check_menu_item_toggled (GtkCheckMenuItem* _sender, gpointer self) {
	_lambda2_ (_sender, self);
}


static Block2Data* block2_data_ref (Block2Data* _data2_) {
	++_data2_->_ref_count_;
	return _data2_;
}


static void block2_data_unref (Block2Data* _data2_) {
	if ((--_data2_->_ref_count_) == 0) {
		_g_object_unref0 (_data2_->self);
		_g_free0 (_data2_->title);
		_g_free0 (_data2_->url);
		g_slice_free (Block2Data, _data2_);
	}
}


static GSList* beta_radio_getChannelMenu (BetaRadio* self, GtkMenu* menu, GSList* group, JsonSoup* json) {
	GSList* result = NULL;
	gint length;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (menu != NULL, NULL);
	g_return_val_if_fail (json != NULL, NULL);
	length = json_soup_length (json);
	{
		gint i;
		i = 0;
		{
			gboolean _tmp0_;
			_tmp0_ = TRUE;
			while (TRUE) {
				Block2Data* _data2_;
				JsonSoup* _tmp2_;
				JsonSoup* _tmp1_;
				char* _tmp3_;
				JsonSoup* _tmp4_;
				char* _tmp5_;
				char* type;
				char* _tmp7_;
				JsonSoup* _tmp6_;
				char* _tmp8_;
				GtkRadioMenuItem* radio;
				JsonSoup* _tmp9_;
				_data2_ = g_slice_new0 (Block2Data);
				_data2_->_ref_count_ = 1;
				_data2_->self = g_object_ref (self);
				if (!_tmp0_) {
					i++;
				}
				_tmp0_ = FALSE;
				if (!(i < length)) {
					block2_data_unref (_data2_);
					break;
				}
				_data2_->title = (_tmp3_ = json_soup_get_string (_tmp2_ = json_soup_object (_tmp1_ = json_soup_array (json, i), "title")), _g_object_unref0 (_tmp2_), _g_object_unref0 (_tmp1_), _tmp3_);
				type = (_tmp5_ = json_soup_get_string (_tmp4_ = json_soup_sibling (json, "type")), _g_object_unref0 (_tmp4_), _tmp5_);
				_data2_->url = (_tmp8_ = beta_radio_filter_url (self, _tmp7_ = json_soup_get_string (_tmp6_ = json_soup_sibling (json, "url")), type), _g_free0 (_tmp7_), _g_object_unref0 (_tmp6_), _tmp8_);
				radio = g_object_ref_sink ((GtkRadioMenuItem*) gtk_radio_menu_item_new_with_label (group, _data2_->title));
				group = gtk_radio_menu_item_get_group (radio);
				g_signal_connect_data ((GtkCheckMenuItem*) radio, "toggled", (GCallback) __lambda2__gtk_check_menu_item_toggled, block2_data_ref (_data2_), (GClosureNotify) block2_data_unref, 0);
				gtk_menu_shell_append ((GtkMenuShell*) menu, (GtkWidget*) ((GtkMenuItem*) radio));
				_tmp9_ = json_soup_grandparent (json);
				_g_object_unref0 (_tmp9_);
				_g_free0 (type);
				_g_object_unref0 (radio);
				block2_data_unref (_data2_);
			}
		}
	}
	result = group;
	return result;
}


static char* string_replace (const char* self, const char* old, const char* replacement) {
	char* result = NULL;
	GError * _inner_error_;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (old != NULL, NULL);
	g_return_val_if_fail (replacement != NULL, NULL);
	_inner_error_ = NULL;
	{
		char* _tmp0_;
		GRegex* _tmp1_;
		GRegex* regex;
		char* _tmp2_;
		regex = (_tmp1_ = g_regex_new (_tmp0_ = g_regex_escape_string (old, -1), 0, 0, &_inner_error_), _g_free0 (_tmp0_), _tmp1_);
		if (_inner_error_ != NULL) {
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch0_g_regex_error;
			}
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		_tmp2_ = g_regex_replace_literal (regex, self, (gssize) (-1), 0, replacement, 0, &_inner_error_);
		if (_inner_error_ != NULL) {
			_g_regex_unref0 (regex);
			if (_inner_error_->domain == G_REGEX_ERROR) {
				goto __catch0_g_regex_error;
			}
			_g_regex_unref0 (regex);
			g_critical ("file %s: line %d: unexpected error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
			g_clear_error (&_inner_error_);
			return NULL;
		}
		result = _tmp2_;
		_g_regex_unref0 (regex);
		return result;
	}
	goto __finally0;
	__catch0_g_regex_error:
	{
		GError * e;
		e = _inner_error_;
		_inner_error_ = NULL;
		{
			g_assert_not_reached ();
			_g_error_free0 (e);
		}
	}
	__finally0:
	if (_inner_error_ != NULL) {
		g_critical ("file %s: line %d: uncaught error: %s (%s, %d)", __FILE__, __LINE__, _inner_error_->message, g_quark_to_string (_inner_error_->domain), _inner_error_->code);
		g_clear_error (&_inner_error_);
		return NULL;
	}
}


static char* beta_radio_filter_url (BetaRadio* self, const char* url, const char* type) {
	char* result = NULL;
	gboolean _tmp0_ = FALSE;
	g_return_val_if_fail (self != NULL, NULL);
	g_return_val_if_fail (url != NULL, NULL);
	g_return_val_if_fail (type != NULL, NULL);
	if (_vala_strcmp0 (type, "mms") == 0) {
		_tmp0_ = g_str_has_prefix (url, "http://") == TRUE;
	} else {
		_tmp0_ = FALSE;
	}
	if (_tmp0_) {
		char* _tmp1_;
		char* _tmp2_;
		result = (_tmp2_ = g_strconcat (_tmp1_ = string_replace (url, "http", "mmsh"), "\\?MSWMExt\\=.asf", NULL), _g_free0 (_tmp1_), _tmp2_);
		return result;
	}
	result = g_strdup (url);
	return result;
}


static void beta_radio_class_init (BetaRadioClass * klass) {
	beta_radio_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (BetaRadioPrivate));
	G_OBJECT_CLASS (klass)->finalize = beta_radio_finalize;
}


static void beta_radio_instance_init (BetaRadio * self) {
	self->priv = BETA_RADIO_GET_PRIVATE (self);
	self->priv->icon = NULL;
	self->priv->menu = NULL;
	self->priv->player = NULL;
}


static void beta_radio_finalize (GObject* obj) {
	BetaRadio * self;
	self = BETA_RADIO (obj);
	_g_object_unref0 (self->priv->icon);
	_g_object_unref0 (self->priv->menu);
	_g_object_unref0 (self->priv->player);
	G_OBJECT_CLASS (beta_radio_parent_class)->finalize (obj);
}


GType beta_radio_get_type (void) {
	static volatile gsize beta_radio_type_id__volatile = 0;
	if (g_once_init_enter (&beta_radio_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (BetaRadioClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) beta_radio_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (BetaRadio), 0, (GInstanceInitFunc) beta_radio_instance_init, NULL };
		GType beta_radio_type_id;
		beta_radio_type_id = g_type_register_static (G_TYPE_OBJECT, "BetaRadio", &g_define_type_info, 0);
		g_once_init_leave (&beta_radio_type_id__volatile, beta_radio_type_id);
	}
	return beta_radio_type_id__volatile;
}


static int _vala_strcmp0 (const char * str1, const char * str2) {
	if (str1 == NULL) {
		return -(str1 != str2);
	}
	if (str2 == NULL) {
		return str1 != str2;
	}
	return strcmp (str1, str2);
}




